// Quest Language Grammar for Pest Parser

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "#" ~ (!"\n" ~ ANY)* }

// Program Entry Point
program = { SOI ~ statement* ~ EOI }

// Statements
statement = {
    use_statement
    | pub_statement
    | let_statement
    | const_declaration
    | del_statement
    | try_statement
    | raise_statement
    | with_statement
    | doc_declaration
    | variable_declaration
    | assignment
    | function_declaration
    | type_declaration
    | trait_declaration
    | impl_declaration
    | if_statement
    | while_statement
    | for_statement
    | return_statement
    | break_statement
    | continue_statement
    | expression_statement
}

// Public statement (pub modifier for exports)
pub_statement = {
    "pub" ~ let_statement
    | "pub" ~ function_declaration
    | "pub" ~ type_declaration
    | "pub" ~ trait_declaration
}

// Use Statement (module imports)
use_statement = {
    "use" ~ string ~ "as" ~ identifier   // use "path" as alias
    | "use" ~ string                     // use "path" (derive alias from filename)
}

// Let Statement (simple variable declaration, supports multiple assignments)
let_statement = { "let" ~ let_binding ~ ("," ~ let_binding)* }
let_binding = { identifier ~ "=" ~ expression }

// Const Declaration (QEP-017 - immutable constants)
const_declaration = { "const" ~ identifier ~ "=" ~ expression }

// Del Statement (variable deletion)
del_statement = { "del" ~ identifier }

// Variable Declaration
variable_declaration = { identifier ~ ":" ~ type_expr ~ ("=" ~ expression)? }

// Assignment (including compound assignment operators)
assignment = {
    identifier ~ index_access ~ compound_op ~ expression
    | identifier ~ "." ~ identifier ~ compound_op ~ expression
    | identifier ~ compound_op ~ expression
}

compound_op = { "+=" | "-=" | "*=" | "/=" | "%=" | "=" }

// Expression Statement
expression_statement = { expression }

// If Statement
if_statement = {
    "if" ~ expression ~ statement* ~ elif_clause* ~ else_clause? ~ "end"
}

elif_clause = { "elif" ~ expression ~ statement* }
else_clause = { "else" ~ statement* }

// While Statement
while_statement = {
    "while" ~ expression ~ statement* ~ "end"
}

// For Statement
for_statement = {
    "for" ~ identifier ~ ("," ~ identifier)? ~ "in" ~ for_range ~ statement* ~ "end"
}

for_range = {
    expression ~ "to" ~ expression ~ ("step" ~ expression)?      // inclusive: 0 to 10 step 2
    | expression ~ "until" ~ expression ~ ("step" ~ expression)? // exclusive: 0 until 10 step 2
    | expression                                                  // collection: array or dict
}

// With Statement (Context Managers - QEP-011)
with_statement = {
    "with" ~ with_item ~ ("," ~ with_item)* ~ statement* ~ "end"
}

with_item = { expression ~ as_clause? }

as_clause = { "as" ~ identifier }

// Return Statement
return_statement = { "return" ~ expression? }
break_statement = { "break" }
continue_statement = { "continue" }

// Exception Handling
try_statement = {
    "try" ~ statement* ~ catch_clause+ ~ ensure_clause? ~ "end"
    | "try" ~ statement* ~ ensure_clause ~ "end"
}

catch_clause = {
    "catch" ~ identifier ~ ":" ~ type_expr ~ statement*  // catch e: ValueError
    | "catch" ~ identifier ~ statement*                   // catch e
}

ensure_clause = { "ensure" ~ statement* }

raise_statement = {
    "raise" ~ expression  // raise "error" or raise ValueError("msg")
    | "raise"             // re-raise current exception
}

// Documentation Declaration (QEP-002)
// Format: % declaration on one line, then docstring on next line(s)
doc_declaration = {
    doc_fun | doc_const | doc_type | doc_trait
}

doc_fun = { "%" ~ "fun" ~ identifier ~ "(" ~ parameter_list? ~ ")" ~ string }
doc_const = { "%" ~ "const" ~ identifier ~ string }
doc_type = { "%" ~ "type" ~ identifier ~ string }
doc_trait = { "%" ~ "trait" ~ identifier ~ string }

// Decorator Declaration (QEP-003)
decorator = { "@" ~ decorator_expression }

decorator_expression = {
    identifier ~ ("." ~ identifier)* ~ decorator_args?
}

decorator_args = {
    "(" ~ ((named_arg | expression) ~ ("," ~ (named_arg | expression))*)? ~ ")"
}

// Function Declaration
function_declaration = {
    decorator* ~ "fun" ~ identifier ~ "(" ~ parameter_list? ~ ")" ~ ("->" ~ type_expr)? ~ statement* ~ "end"
    | decorator* ~ "fun" ~ identifier ~ ("->" ~ type_expr)? ~ statement* ~ "end"
}

parameter_list = { parameter ~ ("," ~ parameter)* }
parameter = {
    identifier ~ ":" ~ type_expr  // typed parameter: x: num
    | identifier                   // untyped parameter: x
}

// Type Declaration
type_declaration = { "type" ~ identifier ~ string? ~ type_member* ~ "end" }

type_member = {
    "pub"? ~ identifier ~ ":" ~ type_expr ~ "?" ~ ("=" ~ expression)?  // Typed optional field: pub x: num? = 5
    | "pub"? ~ identifier ~ ":" ~ type_expr ~ ("=" ~ expression)?      // Typed field: pub x: num = 5
    | "pub"? ~ identifier ~ ("=" ~ expression)?                         // Untyped field: pub x = 5
    | impl_block                                                         // Trait implementation block
    | static_function_declaration                                        // Static method definition
    | function_declaration                                               // Instance method definition
}

static_function_declaration = {
    decorator* ~ "static" ~ "fun" ~ identifier ~ "(" ~ parameter_list? ~ ")" ~ ("->" ~ type_expr)? ~ statement* ~ "end"
    | decorator* ~ "static" ~ "fun" ~ identifier ~ ("->" ~ type_expr)? ~ statement* ~ "end"
}

// Implementation block inside type
impl_block = { "impl" ~ identifier ~ function_declaration+ ~ "end" }

// Trait Declaration
trait_declaration = { "trait" ~ identifier ~ string? ~ trait_method* ~ "end" }

trait_method = {
    "fun" ~ identifier ~ "(" ~ parameter_list? ~ ")" ~ ("->" ~ type_expr)?
}

// Implementation Declaration
impl_declaration = { "impl" ~ identifier ~ ("with" ~ type_list)? ~ "{" ~ function_declaration* ~ "}" }

type_list = { identifier ~ ("," ~ identifier)* }

// Expressions (with precedence from lowest to highest)
expression = { lambda_expr }

lambda_expr = {
    "fun" ~ "(" ~ parameter_list? ~ ")" ~ statement* ~ "end"  // fun (x, y) x + y end
    | elvis_expr
}

// Elvis operator (QEP-019): expr ?: default
// Provides default value if expression is nil
elvis_expr = { logical_or ~ (elvis_op ~ logical_or)* }
elvis_op = { "?:" }

logical_or = { logical_and ~ (or_op ~ logical_and)* }
logical_and = { logical_not ~ (and_op ~ logical_not)* }
logical_not = { not_op ~ logical_not | bitwise_or }

// Operator keywords with word boundaries (prevent matching inside identifiers)
or_op = @{ "or" ~ !(ASCII_ALPHANUMERIC | "_") }
and_op = @{ "and" ~ !(ASCII_ALPHANUMERIC | "_") }
not_op = @{ "not" ~ !(ASCII_ALPHANUMERIC | "_") }

bitwise_or = { bitwise_xor ~ ("|" ~ bitwise_xor)* }
bitwise_xor = { bitwise_and ~ ("^" ~ bitwise_and)* }
bitwise_and = { shift ~ ("&" ~ shift)* }

shift = { comparison ~ (shift_op ~ comparison)* }
shift_op = { "<<" | ">>" }

comparison = { concat ~ (comparison_op ~ concat)* }
comparison_op = { "==" | "!=" | "<=" | ">=" | "<" | ">" }

concat = { addition ~ (".." ~ addition)* }

addition = { multiplication ~ (add_op ~ multiplication)* }
add_op = { "+" | "-" }

multiplication = { unary ~ (mul_op ~ unary)* }
mul_op = { "*" | "/" | "%" }

unary = {
    unary_op ~ unary
    | postfix
}
unary_op = { "-" | "+" | "~" }

postfix = {
    primary ~ (
        "." ~ method_name ~ "(" ~ argument_list? ~ ")"  // method call
        | "." ~ method_name                              // member access
        | index_access                                   // array/dict access
    )*
}

primary = {
    "(" ~ expression ~ ")"
    | identifier ~ ".new" ~ "(" ~ argument_list? ~ ")"  // constructor
    | identifier ~ ".dim" ~ "(" ~ argument_list ~ ")"   // dimension creator
    | identifier ~ "(" ~ argument_list? ~ ")"           // function call
    | array_literal
    | dict_literal
    | literal
    | identifier
}

index_access = { "[" ~ expression ~ ("," ~ expression)* ~ "]" }
argument_list = {
    named_arg ~ ("," ~ named_arg)*      // All named: name: "Alice", age: 30
    | expression ~ ("," ~ expression)*  // All positional (existing)
}

named_arg = { identifier ~ ":" ~ expression }

// Literals
literal = { bytes_literal | number | string | boolean | nil | type_literal }

// Type literals (for use with .is() and other type checks)
// Note: Decimal is NOT a type literal because it's a built-in Type with static methods
type_literal = @{ ("Int" | "Float" | "Str" | "Bool" | "Array" | "Dict" | "Bytes" | "Uuid" | "Num" | "Obj") ~ !(ASCII_ALPHANUMERIC | "_") }

array_literal = {
    "[" ~ array_elements? ~ "]"
}

array_elements = {
    array_row ~ (";" ~ array_row)+  // 2D array syntax
    | expression ~ ("," ~ expression)*
}

array_row = { expression ~ ("," ~ expression)* }

dict_literal = {
    "{" ~ dict_pair ~ ("," ~ dict_pair)* ~ "}"
    | "{" ~ "}"
}

dict_pair = { (identifier | string) ~ ":" ~ expression }

// Types
type_expr = {
    base_type ~ "{" ~ type_expr ~ "}"     // arr{str}, dict{num}
    | base_type ~ dimension_spec          // arr[3,3]
    | base_type
}

dimension_spec = { "[" ~ expression ~ ("," ~ expression)* ~ "]" }

type_keyword = @{
    ("Obj" | "Fun" | "Str" | "Num" | "Nil" | "Bool" | "Array" | "Dict" | "Type"
    | "Int" | "Float" | "Decimal" | "Bytes" | "Uuid")
    ~ !(ASCII_ALPHANUMERIC | "_")
}

base_type = {
    type_keyword
    | qualified_type
    | identifier
}

// Qualified type name: module.Type (e.g., process.Process)
qualified_type = { identifier ~ "." ~ identifier }

// Keywords (must be checked before identifier)
// Use atomic rule and check for word boundary (no alphanumeric/underscore after)
keyword = @{
    ("if" | "elif" | "else" | "end" | "fun" | "type" | "trait" | "impl" | "with"
    | "return" | "static" | "and" | "or" | "not" | "true" | "false" | "nil"
    | "use" | "let" | "del" | "as"
    | "for" | "in" | "to" | "until" | "step" | "while" | "try" | "catch" | "ensure" | "raise"
    | "const" | "break" | "continue" | "pub")
    ~ !(ASCII_ALPHANUMERIC | "_")
}

// Terminals
identifier = @{ !keyword ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// Method name - can be any identifier including keywords (used after '.')
method_name = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// Number literals (order matters - try most specific first)
number = @{
    bigint_literal
    | hex_literal
    | binary_literal
    | octal_literal
    | scientific_notation
    | decimal_number
}

// BigInt literals with 'n' suffix (like JavaScript)
bigint_literal = @{
    (hex_bigint | binary_bigint | octal_bigint | decimal_bigint)
}

hex_bigint = @{
    ("0x" | "0X") ~ ASCII_HEX_DIGIT+ ~ ("_" ~ ASCII_HEX_DIGIT+)* ~ ("n" | "N")
}

binary_bigint = @{
    ("0b" | "0B") ~ ASCII_BIN_DIGIT+ ~ ("_" ~ ASCII_BIN_DIGIT+)* ~ ("n" | "N")
}

octal_bigint = @{
    ("0o" | "0O") ~ ASCII_OCT_DIGIT+ ~ ("_" ~ ASCII_OCT_DIGIT+)* ~ ("n" | "N")
}

decimal_bigint = @{
    !("0" ~ ("x" | "X" | "b" | "B" | "o" | "O")) ~
    ASCII_DIGIT+ ~ ("_" ~ ASCII_DIGIT+)* ~ ("n" | "N")
}

hex_literal = @{
    ("0x" | "0X") ~ ASCII_HEX_DIGIT+ ~ ("_" ~ ASCII_HEX_DIGIT+)* ~ !(ASCII_ALPHANUMERIC)
}

binary_literal = @{
    ("0b" | "0B") ~ ASCII_BIN_DIGIT+ ~ ("_" ~ ASCII_BIN_DIGIT+)* ~ !(ASCII_ALPHANUMERIC)
}

octal_literal = @{
    ("0o" | "0O") ~ ASCII_OCT_DIGIT+ ~ ("_" ~ ASCII_OCT_DIGIT+)* ~ !(ASCII_ALPHANUMERIC)
}

scientific_notation = @{
    ASCII_DIGIT+ ~ ("_" ~ ASCII_DIGIT+)* ~
    ("." ~ ASCII_DIGIT+ ~ ("_" ~ ASCII_DIGIT+)*)? ~
    ("e" | "E") ~
    ("+" | "-")? ~
    ASCII_DIGIT+ ~ ("_" ~ ASCII_DIGIT+)*
}

decimal_number = @{
    // Don't match "0" when followed by x/b/o (literal prefixes)
    // This forces 0x/0b/0o to be parsed as literals (and fail if malformed)
    !("0" ~ ("x" | "X" | "b" | "B" | "o" | "O")) ~
    ASCII_DIGIT+ ~ ("_" ~ ASCII_DIGIT+)* ~
    ("." ~ ASCII_DIGIT+ ~ ("_" ~ ASCII_DIGIT+)*)?
}

string = {
    fstring
    | plain_string
}

// F-strings with variable interpolation: f"Hello {name}" or f'Hello {name}'
fstring = ${
    "f\"" ~ (interpolation | fstring_dq_char)* ~ "\""
    | "f'" ~ (interpolation | fstring_sq_char)* ~ "'"
}

interpolation = { "{" ~ identifier ~ (":" ~ format_spec)? ~ "}" }
format_spec = @{ (!("}" | "{") ~ ANY)+ }

fstring_dq_char = @{
    "\\" ~ ANY        // escaped character
    | ((!("{" | "\"" | "\r" | "\n" | "\\") ~ ANY)+)  // one or more chars except {, ", newlines, backslash
}

fstring_sq_char = @{
    "\\" ~ ANY        // escaped character
    | ((!("{" | "'" | "\r" | "\n" | "\\") ~ ANY)+)  // one or more chars except {, ', newlines, backslash
}

// Plain strings (no interpolation)
plain_string = @{
    "\"\"\"" ~ (!"\"\"\"" ~ ANY)* ~ "\"\"\""  // multi-line triple-quoted string
    | "'''" ~ (!"'''" ~ ANY)* ~ "'''"  // multi-line single-quoted string
    | "\"" ~ (!"\"" ~ !"\r" ~ !"\n" ~ ("\\" ~ ANY | ANY))* ~ "\""  // double-quoted string
    | "'" ~ (!"'" ~ !"\r" ~ !"\n" ~ ("\\" ~ ANY | ANY))* ~ "'"  // single-quoted string
}

// Bytes literal: b"..." or b'...' with escape sequences
bytes_literal = @{
    ^"b\"" ~ bytes_dq_char* ~ "\""
    | ^"b'" ~ bytes_sq_char* ~ "'"
}

bytes_dq_char = @{
    "\\x" ~ ASCII_HEX_DIGIT{2}     // \xFF hex escape
    | "\\n"                         // newline
    | "\\r"                         // carriage return
    | "\\t"                         // tab
    | "\\0"                         // null byte
    | "\\\\"                        // backslash
    | "\\\""                        // escaped double quote
    | (!("\"" | "\\") ~ ANY)       // regular character (not double quote or backslash)
}

bytes_sq_char = @{
    "\\x" ~ ASCII_HEX_DIGIT{2}     // \xFF hex escape
    | "\\n"                         // newline
    | "\\r"                         // carriage return
    | "\\t"                         // tab
    | "\\0"                         // null byte
    | "\\\\"                        // backslash
    | "\\'"                         // escaped single quote
    | (!("'" | "\\") ~ ANY)        // regular character (not single quote or backslash)
}

boolean = @{ ("true" | "false") ~ !(ASCII_ALPHANUMERIC | "_") }
nil = @{ "nil" ~ !(ASCII_ALPHANUMERIC | "_") }
