// Quest Language Grammar for Pest Parser

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "#" ~ (!"\n" ~ ANY)* }

// Program Entry Point
program = { SOI ~ statement* ~ EOI }

// Statements
statement = {
    use_statement
    | let_statement
    | del_statement
    | variable_declaration
    | assignment
    | function_declaration
    | type_declaration
    | impl_declaration
    | if_statement
    | while_statement
    | for_statement
    | iteration_statement
    | return_statement
    | break_statement
    | continue_statement
    | expression_statement
}

// Use Statement (module imports)
use_statement = {
    "use" ~ string ~ "as" ~ identifier   // use "path" as alias
    | "use" ~ string                     // use "path" (derive alias from filename)
}

// Let Statement (simple variable declaration)
let_statement = { "let" ~ identifier ~ "=" ~ expression }

// Del Statement (variable deletion)
del_statement = { "del" ~ identifier }

// Variable Declaration
variable_declaration = { type_expr ~ ":" ~ identifier ~ ("=" ~ expression)? }

// Assignment (including compound assignment operators)
assignment = {
    identifier ~ index_access ~ compound_op ~ expression
    | identifier ~ "." ~ identifier ~ compound_op ~ expression
    | identifier ~ compound_op ~ expression
}

compound_op = { "+=" | "-=" | "*=" | "/=" | "%=" | "=" }

// Expression Statement
expression_statement = { expression }

// If Statement
if_statement = {
    "if" ~ expression ~ statement* ~ elif_clause* ~ else_clause? ~ "end"
}

elif_clause = { "elif" ~ expression ~ statement* }
else_clause = { "else" ~ statement* }

// While Statement
while_statement = {
    "while" ~ expression ~ statement* ~ "end"
}

// For Statement
for_statement = {
    "for" ~ identifier ~ ("," ~ identifier)? ~ "in" ~ for_range ~ statement* ~ "end"
}

for_range = {
    expression ~ "to" ~ expression ~ ("step" ~ expression)?      // inclusive: 0 to 10 step 2
    | expression ~ "until" ~ expression ~ ("step" ~ expression)? // exclusive: 0 until 10 step 2
    | expression                                                  // collection: array or dict
}

// Iteration Statement
iteration_statement = { expression ~ ".each" ~ "->" ~ identifier ~ statement* ~ "end" }

// Return Statement
return_statement = { "return" ~ expression? }
break_statement = { "break" }
continue_statement = { "continue" }

// Function Declaration
function_declaration = {
    "fun" ~ identifier ~ "(" ~ parameter_list? ~ ")" ~ ("->" ~ type_expr)? ~ statement* ~ "end"
    | "fun" ~ identifier ~ ("->" ~ type_expr)? ~ statement* ~ "end"
}

parameter_list = { parameter ~ ("," ~ parameter)* }
parameter = {
    type_expr ~ ":" ~ identifier  // typed parameter: num: x
    | identifier                   // untyped parameter: x
}

// Type Declaration
type_declaration = { "type" ~ identifier ~ "{" ~ type_member* ~ "}" }

type_member = {
    type_expr ~ ":" ~ identifier
    | "fun" ~ identifier ~ "(" ~ parameter_list? ~ ")" ~ ("->" ~ type_expr)?
    | "fun" ~ identifier ~ type_expr ~ ":"
}

// Implementation Declaration
impl_declaration = { "impl" ~ identifier ~ ("with" ~ type_list)? ~ "{" ~ function_declaration* ~ "}" }

type_list = { identifier ~ ("," ~ identifier)* }

// Expressions (with precedence from lowest to highest)
expression = { lambda_expr }

lambda_expr = {
    "fun" ~ "(" ~ parameter_list? ~ ")" ~ statement* ~ "end"  // fun (x, y) x + y end
    | logical_or
}

logical_or = { logical_and ~ ("or" ~ logical_and)* }
logical_and = { bitwise_or ~ ("and" ~ bitwise_or)* }

bitwise_or = { bitwise_and ~ ("|" ~ bitwise_and)* }
bitwise_and = { comparison ~ ("&" ~ comparison)* }

comparison = { concat ~ (comparison_op ~ concat)* }
comparison_op = { "==" | "!=" | "<=" | ">=" | "<" | ">" }

concat = { addition ~ (".." ~ addition)* }

addition = { multiplication ~ (add_op ~ multiplication)* }
add_op = { "+" | "-" }

multiplication = { unary ~ (mul_op ~ unary)* }
mul_op = { "*" | "/" | "%" }

unary = {
    unary_op ~ unary
    | postfix
}
unary_op = { "!" | "-" | "+" }

postfix = {
    primary ~ (
        "." ~ identifier ~ "(" ~ argument_list? ~ ")"  // method call
        | "." ~ identifier                              // member access
        | index_access                                  // array/dict access
    )*
}

primary = {
    "(" ~ expression ~ ")"
    | identifier ~ ".new" ~ "(" ~ argument_list? ~ ")"  // constructor
    | identifier ~ ".dim" ~ "(" ~ argument_list ~ ")"   // dimension creator
    | identifier ~ "(" ~ argument_list? ~ ")"           // function call
    | array_literal
    | dict_literal
    | literal
    | "self"
    | identifier
}

index_access = { "[" ~ expression ~ ("," ~ expression)* ~ "]" }
argument_list = { expression ~ ("," ~ expression)* }

// Literals
literal = { number | string | boolean | nil }

array_literal = {
    "[" ~ array_elements? ~ "]"
}

array_elements = {
    array_row ~ (";" ~ array_row)+  // 2D array syntax
    | expression ~ ("," ~ expression)*
}

array_row = { expression ~ ("," ~ expression)* }

dict_literal = {
    "{" ~ dict_pair ~ ("," ~ dict_pair)* ~ "}"
    | "{" ~ "}"
}

dict_pair = { (identifier | string) ~ ":" ~ expression }

// Types
type_expr = {
    base_type ~ "{" ~ type_expr ~ "}"     // arr{str}, dict{num}
    | base_type ~ dimension_spec          // arr[3,3]
    | base_type
}

dimension_spec = { "[" ~ expression ~ ("," ~ expression)* ~ "]" }

base_type = {
    "obj" | "fun" | "str" | "num" | "nil" | "bool" | "arr" | "dict" | "type"
    | identifier
}

// Keywords (must be checked before identifier)
// Use atomic rule and check for word boundary (no alphanumeric/underscore after)
keyword = @{
    ("if" | "elif" | "else" | "end" | "fun" | "type" | "impl" | "with"
    | "return" | "self" | "and" | "or" | "true" | "false" | "nil"
    | "obj" | "str" | "num" | "bool" | "arr" | "dict" | "use" | "let" | "del" | "as"
    | "for" | "in" | "to" | "until" | "step" | "while")
    ~ !(ASCII_ALPHANUMERIC | "_")
}

// Terminals
identifier = @{ !keyword ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

number = @{
    ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)?
}

string = {
    fstring
    | plain_string
}

// F-strings with variable interpolation: f"Hello {name}"
fstring = ${
    "f\"" ~ (interpolation | fstring_char)* ~ "\""
}

interpolation = { "{" ~ identifier ~ (":" ~ format_spec)? ~ "}" }
format_spec = @{ (!("}" | "{") ~ ANY)+ }

fstring_char = @{
    "\\" ~ ANY        // escaped character
    | ((!("{" | "\"" | "\r" | "\n" | "\\") ~ ANY)+)  // one or more chars except {, ", newlines, backslash
}

// Plain strings (no interpolation)
plain_string = @{
    "\"\"\"" ~ (!"\"\"\"" ~ ANY)* ~ "\"\"\""  // multi-line string
    | "\"" ~ (!"\"" ~ !"\r" ~ !"\n" ~ ("\\" ~ ANY | ANY))* ~ "\""  // single-line string
}

boolean = { "true" | "false" }
nil = { "nil" }
