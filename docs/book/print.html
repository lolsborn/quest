<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Quest Language</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <!-- Quest syntax highlighting - must load BEFORE highlight.js -->
        <script>
        // Store Quest language definition to be registered as soon as hljs loads
        window.QUEST_LANG_DEF = function(hljs) {
          const KEYWORDS = {
            keyword: 'let del if elif else end while for in to until step fun return use as and or not break continue type impl with self',
            literal: 'true false nil',
            built_in: 'puts print'
          };
        
          const STRING = {
            className: 'string',
            variants: [
              { begin: /"""/, end: /"""/, contains: [hljs.BACKSLASH_ESCAPE] },
              {
                begin: /f"/,
                end: /"/,
                contains: [
                  hljs.BACKSLASH_ESCAPE,
                  { className: 'subst', begin: /\{/, end: /\}/ }
                ]
              },
              { begin: /"/, end: /"/, contains: [hljs.BACKSLASH_ESCAPE] }
            ]
          };
        
          return {
            name: 'Quest',
            aliases: ['quest', 'q'],
            keywords: KEYWORDS,
            contains: [
              hljs.COMMENT('#', '$'),
              STRING,
              {
                className: 'number',
                begin: /\b\d+(\.\d+)?/,
                relevance: 0
              },
              {
                className: 'title.function',
                begin: /\b[a-zA-Z_][a-zA-Z0-9_]*(?=\()/
              },
              {
                className: 'title.function',
                begin: /\.[a-zA-Z_][a-zA-Z0-9_]*(?=\()/
              }
            ]
          };
        };
        
        // Intercept hljs when it loads and register Quest before it's used
        (function() {
          let originalHljs = null;
          Object.defineProperty(window, 'hljs', {
            get: function() {
              return originalHljs;
            },
            set: function(value) {
              originalHljs = value;
              if (value && window.QUEST_LANG_DEF) {
                console.log('Registering Quest language');
                value.registerLanguage('quest', window.QUEST_LANG_DEF);
                console.log('Available languages:', value.listLanguages());
              }
            },
            configurable: true
          });
        })();
        </script>

        <meta name="description" content="A batteries-included general-purpose scripting language inspired by Ruby, Python, Go, and Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Quest Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/yourusername/quest" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Quest is a batteries-included general-purpose scripting language designed to <strong>optimize developer productivity while remaining performant</strong>. Built on a pure object-oriented foundation, Quest treats everything as an object—from numbers and strings to functions and modules—while providing the practical tools and libraries needed for real-world scripting, automation, and web development.</p>
<p>Quest draws inspiration from Ruby, Python, Go, and Rust, combining their best ideas into a unique, concise syntax that focuses on simplicity and getting things done.</p>
<h2 id="primary-goal"><a class="header" href="#primary-goal">Primary Goal</a></h2>
<p><strong>Maximize developer productivity without sacrificing performance.</strong> Quest is designed to let you write less code, iterate faster, and ship more quickly—all while maintaining the speed and reliability your applications need.</p>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<ul>
<li><strong>Pure Object-Oriented</strong>: Everything in Quest is an object. Numbers, booleans, strings, functions—all implement the same fundamental object interface.</li>
<li><strong>Batteries Included</strong>: Comprehensive standard library with modules for JSON, hashing, base64, file I/O, HTTP, terminal formatting, and more.</li>
<li><strong>Concise, Simple Syntax</strong>: A unique syntax designed for clarity and brevity. No unnecessary ceremony, just clear intent.</li>
<li><strong>Method-Based Operations</strong>: All operations are method calls, providing consistency and extensibility.</li>
<li><strong>First-Class Functions</strong>: Functions are objects that can be passed, returned, and inspected like any other value.</li>
<li><strong>Module System</strong>: Organize code with a simple and powerful module system.</li>
<li><strong>Interactive REPL</strong>: Experiment and develop interactively with a feature-rich REPL.</li>
<li><strong>Advanced Web Tooling</strong>: Built-in capabilities for web development and API integration.</li>
<li><strong>Fast Execution</strong>: Implemented in Rust for performance that keeps up with your productivity.</li>
</ul>
<h2 id="inspirations"><a class="header" href="#inspirations">Inspirations</a></h2>
<p>Quest takes the best ideas from multiple languages:</p>
<ul>
<li><strong>Ruby</strong>: Object-oriented purity, blocks/closures, developer happiness</li>
<li><strong>Python</strong>: Explicit is better than implicit, batteries-included philosophy</li>
<li><strong>Go</strong>: Simplicity, practical focus, clear error handling</li>
<li><strong>Rust</strong>: Safety through careful design, performance, modern tooling ecosystem</li>
</ul>
<h2 id="philosophy"><a class="header" href="#philosophy">Philosophy</a></h2>
<p>Quest is designed with the following principles:</p>
<ol>
<li><strong>Developer productivity first</strong> - Optimize for writing, reading, and maintaining code quickly.</li>
<li><strong>Performance matters</strong> - Fast iteration doesn't mean slow execution.</li>
<li><strong>Everything is an object</strong> - No special cases, no primitives. This uniformity makes the language easier to learn and reason about.</li>
<li><strong>Batteries included</strong> - Comprehensive standard library means less dependency management and more getting things done.</li>
<li><strong>Simplicity over cleverness</strong> - Straightforward solutions beat clever abstractions.</li>
<li><strong>Explicit is better than implicit</strong> - Variable declarations use <code>let</code>, operations are clear method calls.</li>
<li><strong>Great developer experience</strong> - Clear error messages, helpful documentation, and fast feedback loops.</li>
</ol>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Here's a taste of Quest:</p>
<pre><code class="language-quest"># Variables and basic types
let name = "World"
let count = 42
let active = true

# Everything is an object with methods
puts(name.upper())        # "WORLD"
puts(count.plus(8))       # 50
puts(active.eq(true))     # true

# Arrays and functional operations
let numbers = [1, 2, 3, 4, 5]
let doubled = numbers.map(fun (x) x.times(2) end)
puts(doubled)             # [2, 4, 6, 8, 10]

# Control flow
if count &gt; 40
    puts("Count is high")
elif count &gt; 20
    puts("Count is medium")
else
    puts("Count is low")
end

# Loops
for i in 0 to 4
    puts("Iteration ", i)
end

# Functions
fun greet(name)
    "Hello, " .. name .. "!"
end

puts(greet("Quest"))      # "Hello, Quest!"
</code></pre>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>Continue to the <a href="./getting-started.html">Getting Started</a> section to install Quest and run your first program.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h1>
<p>This guide will help you install Quest and write your first program.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Quest is implemented in Rust. To build from source, you'll need:</p>
<ul>
<li>Rust toolchain (rustc, cargo) - Install from <a href="https://rust-lang.org">rust-lang.org</a></li>
<li>Git (to clone the repository)</li>
</ul>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<h3 id="building-from-source"><a class="header" href="#building-from-source">Building from Source</a></h3>
<ol>
<li>Clone the repository:</li>
</ol>
<pre><code class="language-bash">git clone https://github.com/yourusername/quest.git
cd quest
</code></pre>
<ol start="2">
<li>Build the project:</li>
</ol>
<pre><code class="language-bash">cargo build --release
</code></pre>
<ol start="3">
<li>The Quest executable will be located at:</li>
</ol>
<pre><code class="language-bash">./target/release/quest
</code></pre>
<ol start="4">
<li>(Optional) Add to your PATH or create an alias:</li>
</ol>
<pre><code class="language-bash"># Add to ~/.bashrc or ~/.zshrc
alias quest='/path/to/quest/target/release/quest'
</code></pre>
<h2 id="the-repl"><a class="header" href="#the-repl">The REPL</a></h2>
<p>Quest includes an interactive Read-Eval-Print Loop (REPL) for experimentation and learning.</p>
<h3 id="starting-the-repl"><a class="header" href="#starting-the-repl">Starting the REPL</a></h3>
<p>Run Quest without arguments to start the REPL:</p>
<pre><code class="language-bash">./target/release/quest
</code></pre>
<p>You'll see a prompt:</p>
<pre><code class="language-text">quest&gt;
</code></pre>
<h3 id="repl-features"><a class="header" href="#repl-features">REPL Features</a></h3>
<p>The REPL supports:</p>
<ul>
<li><strong>Multi-line input</strong>: Start blocks with <code>if</code>, <code>fun</code>, <code>while</code>, <code>for</code> and the REPL will continue accepting input until <code>end</code></li>
<li><strong>Variable persistence</strong>: Variables declared with <code>let</code> persist across REPL sessions</li>
<li><strong>Automatic printing</strong>: Expression results are automatically displayed (except <code>nil</code>)</li>
<li><strong>Error recovery</strong>: Syntax or runtime errors won't crash the REPL</li>
</ul>
<h3 id="example-repl-session"><a class="header" href="#example-repl-session">Example REPL Session</a></h3>
<pre><code class="language-text">quest&gt; let x = 10
quest&gt; x.plus(5)
15
quest&gt; let greet = fun (name)
  ..&gt;     "Hello, " .. name
  ..&gt; end
quest&gt; greet("World")
"Hello, World"
quest&gt; for i in 0 to 3
  ..&gt;     puts(i)
  ..&gt; end
0
1
2
3
</code></pre>
<h2 id="running-script-files"><a class="header" href="#running-script-files">Running Script Files</a></h2>
<p>Quest can execute programs from files with the <code>.q</code> extension.</p>
<h3 id="your-first-script"><a class="header" href="#your-first-script">Your First Script</a></h3>
<p>Create a file called <code>hello.q</code>:</p>
<pre><code class="language-quest"># hello.q - Your first Quest program

let name = "World"
puts("Hello, ", name, "!")

# Calculate something
let x = 5
let y = 10
puts("The sum of ", x, " and ", y, " is ", x.plus(y))
</code></pre>
<p>Run it:</p>
<pre><code class="language-bash">./target/release/quest hello.q
</code></pre>
<p>Output:</p>
<pre><code class="language-text">Hello, World!
The sum of 5 and 10 is 15
</code></pre>
<h3 id="using-standard-input"><a class="header" href="#using-standard-input">Using Standard Input</a></h3>
<p>Quest can also read from standard input:</p>
<pre><code class="language-bash">echo 'puts("Hello from stdin!")' | ./target/release/quest
</code></pre>
<p>Or:</p>
<pre><code class="language-bash">./target/release/quest &lt; script.q
</code></pre>
<h2 id="basic-syntax-overview"><a class="header" href="#basic-syntax-overview">Basic Syntax Overview</a></h2>
<p>Here's a quick reference to get you started:</p>
<h3 id="variables"><a class="header" href="#variables">Variables</a></h3>
<pre><code class="language-quest">let x = 42              # Declare with let
x = 100                 # Assign (must be declared first)
</code></pre>
<h3 id="data-types"><a class="header" href="#data-types">Data Types</a></h3>
<pre><code class="language-quest">let num = 42            # Numbers (integers and floats)
let str = "hello"       # Strings
let bool = true         # Booleans (true/false)
let arr = [1, 2, 3]    # Arrays
let dict = {"key": "value"}  # Dictionaries
let nothing = nil       # Nil
</code></pre>
<h3 id="functions"><a class="header" href="#functions">Functions</a></h3>
<pre><code class="language-quest">fun add(a, b)
    a.plus(b)
end

# Lambdas
let double = fun (x) x.times(2) end
</code></pre>
<h3 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h3>
<pre><code class="language-quest"># If/elif/else
if condition
    # code
elif other_condition
    # code
else
    # code
end

# While loops
while condition
    # code
end

# For loops
for i in 0 to 10
    # code
end

for item in array
    # code
end
</code></pre>
<h3 id="operators"><a class="header" href="#operators">Operators</a></h3>
<pre><code class="language-quest"># Arithmetic
x.plus(y)    # or x + y
x.minus(y)   # or x - y
x.times(y)   # or x * y
x.div(y)     # or x / y

# Comparison
x == y
x != y
x &lt; y
x &gt; y

# Logical
x and y
x or y
!x

# String concatenation
"hello" .. " " .. "world"
</code></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Now that you have Quest installed and understand the basics:</p>
<ul>
<li>Explore the <a href="./language/index.html">Language Reference</a> for complete language documentation</li>
<li>Check out the <a href="./stdlib/index.html">Standard Library</a> to see available modules and functions</li>
<li>Read about <a href="./language/control-flow.html">Control Flow</a> and <a href="./language/loops.html">Loops</a></li>
<li>Learn about the <a href="./language/objects.html">Object System</a></li>
</ul>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<ul>
<li>Read the error messages carefully—Quest provides helpful error messages</li>
<li>Use the REPL to experiment and test ideas</li>
<li>Check the <a href="./examples/index.html">Examples</a> section for common patterns</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-types"><a class="header" href="#object-types">Object types</a></h1>
<p>In quest everything is an <code>obj</code>.  Similar to Ruby even integers are objects!  This means</p>
<p><code>5 + 5</code> is equivalent to <code>5.plus(5)</code> becuase 5 is a <code>num</code> type which inherits <code>obj</code></p>
<h2 id="object-type-members"><a class="header" href="#object-type-members">Object type members</a></h2>
<ul>
<li><strong>obj.cls()</strong> - str representation of object type def</li>
<li><strong>obj.type()</strong> - pointer to the the interface representation for that type instance</li>
<li><strong>obj.new() nil</strong> - Creates and returns an instance of that type</li>
<li><strong>obj.del() nil</strong> - deletes / frees that object</li>
<li><strong>obj.is(type) bool</strong> - returns bool if obj implements type</li>
</ul>
<h3 id="_under-functions"><a class="header" href="#_under-functions">_under functions</a></h3>
<p>Functions starting with an underscore are reserved for top level types (not implementations)</p>
<h4 id="string-representations"><a class="header" href="#string-representations">String representations</a></h4>
<ul>
<li><strong>obj._str()</strong> str - returns string representation of the object</li>
<li><strong>obj._rep()</strong> str - string representation in repl</li>
<li><strong>obj._doc()</strong> str - documentation string</li>
</ul>
<h3 id="special-functions"><a class="header" href="#special-functions">Special functions</a></h3>
<ul>
<li><strong>obj._id()</strong> num - unique integer identifier for that object</li>
</ul>
<h3 id="object-functions"><a class="header" href="#object-functions">Object functions</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>All types in the language derive from <code>Obj</code> (Object), which serves as the base type for the type system.</p>
<h2 id="core-types"><a class="header" href="#core-types">Core Types</a></h2>
<ul>
<li><strong>obj</strong> - Base type from which all other types derive</li>
<li><strong>fun</strong> - Function type</li>
<li><strong>str</strong> - String type</li>
<li><strong>num</strong> - Number type (can represent both ints and floats)</li>
<li><strong>nil</strong> - Null/nil type</li>
<li><strong>bool</strong> - Boolean type</li>
<li><strong>arr</strong> - Array type</li>
<li><strong>dict</strong> - Dictionary/map type</li>
</ul>
<h2 id="type-hierarchy"><a class="header" href="#type-hierarchy">Type Hierarchy</a></h2>
<pre><code class="language-quest">obj
├── fun
├── str
├── num
├── nil
├── bool
├── arr
└── dict
└── type # complex type
```quest


## Arrays

### String Array

```quest
arr{str}: lines = [
    "Hello",
    "World"
]
lines.each -&gt; l:
    puts(l)
end
# Output:
# "Hello"
# "World"
```quest

### 2D array
```quest
arr{num} a[3,3] = [
    1, 2, 3;
    4, 5, 6;
    7, 8, 9;
]

a.each -&gt; row:
    sum = 0
    row.each -&gt; col:
        sum += col
    end
    puts(sum)
end
# Output:
# 6
# 15
# 24
```quest

## Multi Dimensional Matrixes
```quest
arr{num} x = arr.dim(3,3) # 3x3 matrix
puts(x)
# [
#   0, 0, 0
#   0, 0, 0
#   0, 0, 0
# ],[
#   0, 0, 0
#   0, 0, 0
#   0, 0, 0
# ],[
#   0, 0, 0
#   0, 0, 0
#   0, 0, 0
# ]
```quest
```quest
arr{num} y = arr.dim(num,4,2) # 4x2 matrix
puts(y)
# [
#   0, 0
#   0, 0
#   0, 0
#   0, 0
# ]
```quest

```quest
arr{num} z = arr.dim(num,2,3) # 2x3 matrix
puts(z)
# [
#   0, 0, 0
#   0, 0, 0
# ]
```quest


## Complex Types / Type Interfaces

The type keyword declares a new complex type.  A type can be used both as a class or an interface.

type Car {
    str: foo
    num: bar
    fun baz(num: x, num: z) -&gt; str # function example No : at the end of declaration!
}

type Drive {
    num: speed
    fun go nil: # () optional if there are no arguments.  Must still be present when calling
}

type Fly {
    num: altitude
}

type Box {
    num: h
    num: w
    num: d
}

# the implementation of a type is declared separately from the type description / interface.
impl Car with Drive, Fly {

    fun baz(num: x, num: z) -&gt; str:
        puts(self.foo)
        self.bar + x + z # implicit return
    end

    fun go { # implied nil return
        puts("Height: " + alt)
        puts("Speed: " + speed)
    }

}

repl[0]&gt; c = Car.new()
repl[1]&gt; c.is(Fly)
   true
repl[2]&gt; c.is(Box)
   false
repl[3] c.altitutde = 1000
repl[4] c.speed = 50
repl[5] c.go()
   Height: 1000
   Speed: 50
repl[6] Box.new()
   Error: There is no impl for Box

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variable-scoping-in-quest"><a class="header" href="#variable-scoping-in-quest">Variable Scoping in Quest</a></h1>
<p>Quest uses lexical scoping with block-level scope for variables. Understanding how variables are scoped is essential for writing correct programs.</p>
<h2 id="variable-declaration"><a class="header" href="#variable-declaration">Variable Declaration</a></h2>
<p>Variables are declared using the <code>let</code> keyword:</p>
<pre><code class="language-quest">let x = 10
let name = "Alice"
let items = [1, 2, 3]
```quest

## Global Scope

Variables declared at the top level of a program or REPL session exist in the global scope:

```quest
let global_var = 100

fun print_global()
    puts(global_var)  # Can access global variable
end

print_global()  # Prints: 100
```quest

## Function Scope

Variables declared inside a function are local to that function:

```quest
let x = 10  # Global

fun example()
    let x = 20  # Local to example()
    puts(x)     # Prints: 20
end

example()
puts(x)  # Prints: 10 (global x unchanged)
```quest

### Parameter Scope

Function parameters create local variables:

```quest
fun greet(name)
    # 'name' is a local variable (parameter)
    puts("Hello, ", name)
end

greet("Bob")  # Prints: Hello, Bob
# puts(name)  # Error: name is not defined here
```quest

## Shadowing

Inner scopes can shadow (hide) variables from outer scopes:

```quest
let x = 1

fun outer()
    let x = 2
    puts("outer x: ", x)  # Prints: outer x: 2

    fun inner()
        let x = 3
        puts("inner x: ", x)  # Prints: inner x: 3
    end

    inner()
    puts("outer x again: ", x)  # Prints: outer x again: 2
end

outer()
puts("global x: ", x)  # Prints: global x: 1
```quest

## Deleting Variables

You can remove a variable from the current scope using `del`:

```quest
let x = 10
puts(x)  # Prints: 10

del x
# puts(x)  # Error: x is not defined
```quest

### Use Cases for `del`

**1. Free up memory for large data structures:**

```quest
let large_data = read_large_file("data.csv")
process(large_data)
del large_data  # Free memory after processing
```quest

**2. Explicitly mark variables as no longer needed:**

```quest
let temp_result = calculate()
save_to_file(temp_result)
del temp_result  # Clearly indicate we're done with this
```quest

**3. Remove variables before scope ends:**

```quest
fun process_data()
    let cache = {}
    # ... use cache ...
    del cache  # Clean up before function returns
    return result
end
```quest

### Scope Restrictions

`del` only works on variables in the current scope:

```quest
let global_var = 100

fun example()
    let local_var = 50
    del local_var  # OK - deletes local variable

    # del global_var  # Error: cannot delete variable from outer scope
end
```quest

### Deleting and Redeclaration

After deleting a variable, you can redeclare it:

```quest
let x = 10
del x
let x = 20  # OK - x was deleted first
puts(x)  # Prints: 20
```quest

### What You Cannot Delete

- **Module imports:**
  ```quest
  use math
  # del math  # Error: cannot delete module
</code></pre>
<ul>
<li>
<p><strong>Function parameters:</strong></p>
<pre><code class="language-quest">fun example(x)
    # del x  # Error: cannot delete parameter
end
</code></pre>
</li>
<li>
<p><strong>Built-in functions:</strong></p>
<pre><code class="language-quest"># del puts  # Error: cannot delete built-in function
</code></pre>
</li>
</ul>
<h2 id="block-scope"><a class="header" href="#block-scope">Block Scope</a></h2>
<p>Control structures (if, elif, else) create new scopes:</p>
<pre><code class="language-quest">let x = 10

if true
    let x = 20  # New variable, shadows outer x
    puts(x)     # Prints: 20
end

puts(x)  # Prints: 10
```quest

### If/Elif/Else Scoping

Each branch creates its own scope:

```quest
let value = 5

if value &lt; 0
    let msg = "negative"
    puts(msg)
elif value == 0
    let msg = "zero"  # Different variable from if branch
    puts(msg)
else
    let msg = "positive"  # Different variable from other branches
    puts(msg)
end

# puts(msg)  # Error: msg not defined here
```quest

## Variable Assignment vs Declaration

Quest supports reassignment to variables in the same scope:

```quest
let x = 10  # Declaration
puts(x)     # Prints: 10

x = 20      # Reassignment
puts(x)     # Prints: 20
```quest

### Reassignment in Function Scopes

When reassigning from within a function, Quest creates a new local variable rather than modifying the outer scope:

```quest
let x = 10

fun modify()
    x = 20  # Creates new local variable 'x', doesn't modify outer x
end

modify()
puts(x)  # Prints: 10 (outer x unchanged)
```quest

To modify a variable from the same scope, reassign it directly:

```quest
let x = 10
x = 20       # OK - same scope
puts(x)      # Prints: 20
```quest

## Closures and Captured Variables

Functions can read variables from their enclosing scope:

```quest
let message = "Hello"

fun greet(name)
    # Can read 'message' from outer scope
    puts(message, ", ", name)
end

greet("Alice")  # Prints: Hello, Alice
```quest

**Note:** Quest currently creates new local variables when using assignment (`x = value`) inside functions, rather than modifying captured variables. This means true closures with mutable state aren't fully supported yet.

```quest
let count = 0

fun increment()
    count = count + 1  # Creates local 'count', doesn't modify outer
    puts(count)        # Prints: 1
end

increment()
puts(count)  # Still prints: 0
```quest

This is a current limitation. For now, use same-scope reassignment or pass/return values explicitly.

## Module Scope

When you use a module, it creates a variable in the current scope:

```quest
use math

# 'math' is now a variable in this scope
puts(math.pi)

fun example()
    # Can access math from outer scope
    let result = math.sin(1.5)
    puts(result)
end
```quest

### Module Aliasing

You can alias modules to different names:

```quest
use math as m

puts(m.pi)
puts(m.cos(0))
```quest

## Scope Best Practices

### 1. Minimize Global Variables

Prefer passing data as function parameters:

```quest
# Avoid:
let total = 0

fun add_to_total(n)
    total = total + n
end

# Prefer:
fun add(a, b)
    return a + b
end

let total = add(10, 20)
```quest

### 2. Use Descriptive Names

Avoid shadowing unless intentional:

```quest
# Avoid:
let data = [1, 2, 3]

fun process()
    let data = [4, 5, 6]  # Shadows outer data - confusing
    # ...
end

# Prefer:
let input_data = [1, 2, 3]

fun process()
    let processed_data = [4, 5, 6]  # Clear intention
    # ...
end
```quest

### 3. Limit Variable Lifetime

Declare variables in the narrowest scope possible:

```quest
# Avoid:
fun calculate()
    let temp1 = 10
    let temp2 = 20
    let result = 0

    if temp1 &gt; 5
        result = temp1 * temp2
    end

    return result
end

# Prefer:
fun calculate()
    let temp1 = 10
    let temp2 = 20

    if temp1 &gt; 5
        let result = temp1 * temp2  # Scoped to if block
        return result
    end

    return 0
end
```quest

### 4. Understand Closure Limitations

Quest functions can read from outer scopes but cannot modify them with assignment:

```quest
let counter = 0

let increment = fun ()
    counter = counter + 1  # Creates local counter, doesn't modify outer
    puts(counter)
end

increment()  # Prints: 1
increment()  # Prints: 1 (resets each time)
puts(counter)  # Still: 0
```quest

For now, use same-scope modification or pass state explicitly:

```quest
# Same-scope modification works:
let counter = 0
counter = counter + 1
puts(counter)  # 1
```quest

## Common Scoping Errors

### Undefined Variable

```quest
fun example()
    puts(x)  # Error: x not defined
end

let x = 10
example()
```quest

Variables must be defined before use, even if they exist in a later scope.

### Variable Redeclaration

```quest
let x = 10
let x = 20  # Error: variable x already declared
```quest

Cannot redeclare a variable in the same scope. Use shadowing or a new scope instead.

### Out of Scope Access

```quest
if true
    let temp = 42
end

puts(temp)  # Error: temp not defined in this scope
```quest

Variables don't leak out of their declaring scope.

## Scope and Iteration

Quest currently doesn't have traditional for loops, but iteration methods respect scope:

```quest
let arr = [1, 2, 3]

arr.each(fun (item)
    # 'item' is scoped to this function
    puts(item * 2)
end)

# puts(item)  # Error: item not defined here
```quest

## Comparing with Other Languages

### JavaScript

```javascript
// JavaScript (var vs let)
if (true) {
    var x = 10;  // Function-scoped
    let y = 20;  // Block-scoped
}
console.log(x);  // 10 (works with var)
console.log(y);  // Error (let is block-scoped)
```quest

```quest
# Quest (similar to JavaScript's 'let')
if true
    let x = 10  # Block-scoped
end

puts(x)  # Error: x not defined
```quest

### Python

```python
# Python (global keyword needed for assignment)
x = 10

def modify():
    global x  # Must declare global to assign
    x = 20

modify()
print(x)  # 20
```quest

```quest
# Quest (creates local variable in function scope)
let x = 10

fun modify()
    x = 20  # Creates new local x, doesn't modify outer
end

modify()
puts(x)  # 10 (outer x unchanged)
```quest

### Rust

```rust
// Rust (explicit mutability)
let mut x = 10;  // Mutable
x = 20;  // OK

let y = 10;  // Immutable
y = 20;  // Error
```quest

```quest
# Quest (mutable by default in same scope)
let x = 10
x = 20  # OK - reassignment in same scope
puts(x)  # 20
```quest

## Future Features

Quest may add these scoping-related features:

1. **Cross-Scope Assignment** - Modify variables from outer scopes in closures
2. **Const Variables** - Explicitly immutable bindings
3. **Loop Scoping** - For/while loop variable scoping rules
4. **Destructuring** - Scoped pattern matching for arrays/dicts
5. **Block Expressions** - Return values from blocks with scoped variables

## Summary

- Quest uses **lexical scoping** - inner scopes can access outer scope variables
- Variables are **block-scoped** - limited to the block they're declared in
- Functions create **new scopes** for parameters and local variables
- **Shadowing** allows reusing variable names in nested scopes
- **Closures** capture variables from enclosing scopes
- Variables must be **declared before use** in their scope
- **`del` statement** removes variables from the current scope
- **Module imports** create variables in the current scope

Understanding scoping helps write clearer, more maintainable Quest programs.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow-1"><a class="header" href="#control-flow-1">Control Flow</a></h1>
<h2 id="if"><a class="header" href="#if">If</a></h2>
<pre><code class="language-quest">if condition
    # Code
elif condition
    # Code for second condition
else
    # Do this if all other conditions are false
end
```quest
If statements can also fit on one line

```quest
if friendly == true puts("Hi") else puts("Bye") end
```quest</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loops"><a class="header" href="#loops">Loops</a></h1>
<p>Quest provides three loop constructs that cover all iteration needs with clean, readable syntax.</p>
<h2 id="while-loop"><a class="header" href="#while-loop"><code>while</code> Loop</a></h2>
<p>Repeats while a condition is true.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="language-quest">while condition
    # statements
end
```quest

**Examples:**
```quest
# Basic counter
let i = 0
while i &lt; 5
    puts(i)
    i = i + 1
end

# Process until complete
while !queue.empty()
    let item = queue.pop()
    process(item)
end

# Infinite loop with break
while true
    let line = read_line()
    if line == "quit"
        break
    end
    process(line)
end
```quest

## `for` Loop

Iterates over collections and numeric ranges.

**Syntax:**
```quest
# Iterate over collection
for item in collection
    # statements
end

# Numeric range (inclusive)
for i in start to end
    # statements
end

# Numeric range (exclusive)
for i in start until end
    # statements
end

# With step
for i in start to end step increment
    # statements
end

# With index
for item, index in collection
    # statements
end
```quest

**Examples:**
```quest
# Array iteration
let names = ["Alice", "Bob", "Charlie"]
for name in names
    puts("Hello, ", name)
end

# Numeric ranges
for i in 0 to 4
    puts(i)  # 0, 1, 2, 3, 4
end

for i in 0 until 5
    puts(i)  # 0, 1, 2, 3, 4
end

# With step
for i in 0 to 10 step 2
    puts(i)  # 0, 2, 4, 6, 8, 10
end

# Countdown
for i in 10 to 0 step -1
    puts(i)
end

# With index
for item, i in ["a", "b", "c"]
    puts(i, ": ", item)  # 0: a, 1: b, 2: c
end

# Dictionary iteration
let scores = {"Alice": 95, "Bob": 87}
for key, value in scores
    puts(key, " scored ", value)
end

# Nested loops
for row in 0 to 2
    for col in 0 to 2
        puts("(", row, ", ", col, ")")
    end
end
```quest

## `.each` Method

Functional-style iteration on collections.

**Syntax:**
```quest
collection.each(fun (item)
    # statements
end)

dictionary.each(fun (key, value)
    # statements
end)
```quest

**Examples:**
```quest
# Array iteration
[1, 2, 3, 4, 5].each(fun (n)
    puts(n * 2)
end)

# Dictionary iteration
{"a": 1, "b": 2}.each(fun (key, value)
    puts(key, " = ", value)
end)

# Method chaining
numbers
    .filter(fun (n) n &gt; 5 end)
    .map(fun (n) n * 2 end)
    .each(fun (n) puts(n) end)
```quest

## Loop Control

### `break`

Exits the innermost loop immediately.

```quest
for i in 0 to 100
    if i == 10
        break
    end
    puts(i)
end
```quest

### `continue`

Skips the rest of the current iteration.

```quest
# Skip even numbers
for i in 0 to 10
    if i % 2 == 0
        continue
    end
    puts(i)  # Only odd numbers
end
```quest

## Common Patterns

### Process All Items
```quest
for user in users
    send_email(user)
end
```quest

### Numeric Iteration
```quest
for i in 0 to 9
    print(i, " ")
end
puts()
```quest

### Conditional Processing
```quest
while has_more_data()
    let data = fetch_next()
    process(data)
end
```quest

### Infinite Loop
```quest
while true
    let input = prompt("Enter command: ")
    if input == "quit"
        break
    end
    execute(input)
end
```quest

### Functional Pipeline
```quest
data
    .filter(fun (x) x &gt; 0 end)
    .map(fun (x) x * 2 end)
    .each(fun (x) puts(x) end)
```quest

### Matrix Iteration
```quest
for row in 0 until height
    for col in 0 until width
        process(image[row][col])
    end
end
```quest

### Skip Invalid Items
```quest
for file in files
    if !file.exists()
        continue
    end
    process_file(file)
end
```quest

## Implementation Status

| Feature | Status |
|---------|--------|
| `while` loops | ✅ Implemented |
| `.each` method | ✅ Implemented |
| `for..in` loops | ❌ Not implemented |
| `break` statement | ❌ Not implemented |
| `continue` statement | ❌ Not implemented |
| Range `to` | ❌ Not implemented |
| Range `until` | ❌ Not implemented |
| `step` clause | ❌ Not implemented |
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-1"><a class="header" href="#functions-1">Functions</a></h1>
<p>Quest supports both named user-defined functions and anonymous functions (lambdas).</p>
<h2 id="user-defined-functions"><a class="header" href="#user-defined-functions">User-Defined Functions</a></h2>
<h3 id="basic-syntax"><a class="header" href="#basic-syntax">Basic Syntax</a></h3>
<p>Functions are declared using the <code>fun</code> keyword and must end with <code>end</code>:</p>
<pre><code class="language-quest">fun function_name(parameters)
    statement1
    statement2
    return_value
end
```quest

### Parameters

Functions can have zero or more parameters. Parameters are untyped:

```quest
fun greet(name)
    puts("Hello, " .. name .. "!")
end

fun add(x, y)
    x + y
end

fun get_pi()
    3.14159
end
```quest

### Return Values

The last expression in a function body is automatically returned. No explicit `return` statement is needed:

```quest
fun add(x, y)
    x + y
end

let result = add(5, 3)  # result = 8
```quest

### Calling Functions

Functions are called using parentheses with arguments:

```quest
greet("World")           # Prints: Hello, World!
let sum = add(10, 20)    # sum = 30
let pi = get_pi()        # pi = 3.14159
```quest

**Note:** Parentheses are required even for zero-parameter functions.

### Multiple Statements

Functions can contain multiple statements. Only the last expression is returned:

```quest
fun calculate(x, y)
    let doubled = x * 2
    let sum = doubled + y
    sum
end

let result = calculate(5, 3)  # result = 13
```quest

### Examples

```quest
# Simple greeting
fun greet(name)
    puts("Hello, " .. name .. "!")
end

greet("Alice")
greet("Bob")

# Function with return value
fun square(n)
    n * n
end

puts("5 squared is ", square(5))

# Function with multiple statements
fun describe(value)
    puts("The value is: ", value)
    let doubled = value * 2
    puts("Doubled: ", doubled)
    doubled
end

let result = describe(7)
puts("Returned: ", result)

# Parameterless function
fun random_greeting()
    "Hello!"
end

puts(random_greeting())
```quest

## Anonymous Functions (Lambdas)

Anonymous functions, also called lambdas, are functions without a name. They use the same syntax as named functions, but without the function name.

### Syntax

```quest
fun (param1, param2) body end
```quest

### Examples

```quest
# Single expression
fun (x) x * 2 end

# Multiple parameters
fun (x, y) x + y end

# String concatenation
fun (name) "Hello, " .. name end
```quest

### Multi-Statement Lambdas

For lambdas with multiple statements:

```quest
fun (x, y)
    let sum = x + y
    let product = x * y
    sum + product
end
```quest

### Using Lambdas

Anonymous functions can be:
- Assigned to variables
- Passed as arguments to other functions
- Called immediately

```quest
# Assign to variable
let double = fun (x) x * 2 end
puts(double(5))  # Prints: 10

# Multi-parameter lambda
let add = fun (x, y) x + y end
puts(add(3, 4))  # Prints: 7

# Lambda with multiple statements
let compute = fun (x, y)
    let a = x * 2
    let b = y * 3
    a + b
end

puts(compute(5, 10))  # Prints: 40
```quest

### Parameterless Lambdas

Lambdas can have zero parameters:

```quest
let greet = fun () "Hello, World!" end
puts(greet())
```quest

## Function Scope

Functions create their own scope and have access to:
1. Their own parameters
2. Variables from the parent scope (closure behavior)

```quest
let multiplier = 10

fun scale(n)
    n * multiplier
end

puts(scale(5))  # Prints: 50
```quest

## Differences Between Named and Anonymous Functions

| Feature | Named Functions | Anonymous Functions |
|---------|----------------|---------------------|
| Syntax | `fun name(params) ... end` | `fun (params) ... end` |
| Name | Required | None (assigned to variable) |
| Declaration | Statement | Expression |
| Multi-line | Always uses `end` | Always uses `end` |
| Usage | Direct call by name | Call via variable or immediate invocation |

## Common Patterns

### Helper Functions

```quest
fun is_even(n)
    n % 2 == 0
end

fun is_odd(n)
    n % 2 != 0
end

if is_even(42)
    puts("42 is even")
end
```quest

### Function Composition

```quest
fun double(x)
    x * 2
end

fun square(x)
    x * x
end

fun double_then_square(x)
    square(double(x))
end

puts(double_then_square(3))  # Prints: 36 (3 * 2 = 6, 6 * 6 = 36)
```quest

### Lambdas as Variables

```quest
let operations = [
    fun (x) x + 1 end,
    fun (x) x * 2 end,
    fun (x) x * x end
]

# Future: when we have array iteration
# operations[0](5)  # Would return 6
```quest

## Best Practices

1. **Use named functions** for reusable, well-defined operations
2. **Use lambdas** for short, one-off operations or when passing functions as data
3. **Keep functions focused** - each function should do one thing well
4. **Use descriptive names** for named functions
5. **Keep lambdas simple** - if it's complex, use a named function instead

## Limitations (Current Implementation)

- No default parameter values
- No variable number of arguments (varargs)
- No explicit `return` statement (last expression is always returned)
- No function overloading
- No type annotations on parameters or return values (planned but not enforced)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<h2 id="import-syntax"><a class="header" href="#import-syntax">Import Syntax</a></h2>
<p>Quest supports flexible module import syntax:</p>
<h3 id="standard-library-modules"><a class="header" href="#standard-library-modules">Standard Library Modules</a></h3>
<p>Import built-in modules by name (no quotes):</p>
<pre><code class="language-quest">use math
use os
use term
use hash
use json
use io
```quest

Available standard library modules:
- **math** - Mathematical functions and constants (sin, cos, pi, etc.)
- **os** - Operating system utilities and module search paths
- **term** - Terminal colors and formatting
- **hash** - Hashing functions (MD5, SHA, etc.)
- **json** - JSON parsing and serialization

### External Files with Automatic Aliases

Import `.q` files and Quest automatically derives the alias from the filename:

```quest
use "utils/helpers"      # Imports as "helpers" (derived from filename)
use "lib/math/advanced"  # Imports as "advanced"
use "std/test"           # Imports as "test"
```quest

The `.q` extension is optional and will be added automatically:

```quest
use "utils/helpers.q"    # Same as use "utils/helpers"
use "utils/helpers"      # Automatically becomes "utils/helpers.q"
```quest

### Explicit Aliases with `as` Keyword

Use the `as` keyword to specify a custom alias:

```quest
use "std/test" as test_framework
use "utils/helpers" as utils
use "lib/math/advanced" as math
```quest

## External Modules

## Module Search Path

When importing external modules with `use "path"` or `use "path" as alias`, Quest searches for the module file in the following order:

1. **Current working directory** - Always checked first
2. **Directories in `os.search_path`** - User-modifiable at runtime
3. **Directories from `QUEST_INCLUDE` environment variable** - Set before starting Quest

### Search Path Priority

The search path is constructed with this precedence:
1. Current directory (implicit, always first)
2. Paths prepended to `os.search_path` at runtime (highest priority for user additions)
3. Paths from `QUEST_INCLUDE` environment variable (loaded at startup)

### Using QUEST_INCLUDE

Set the `QUEST_INCLUDE` environment variable to add default module search directories:

```bash
# Unix/Linux/macOS (colon-separated)
export QUEST_INCLUDE="/usr/local/lib/quest:/home/user/quest_modules"
./quest

# Windows (semicolon-separated)
set QUEST_INCLUDE=C:\quest\lib;C:\Users\user\quest_modules
quest.exe
```quest

### Runtime Path Inspection

You can inspect the search path at runtime using array methods:

```q
use os

# View current search paths
puts("Search paths:", os.search_path)
puts("Length:", os.search_path.len())

# Get first and last paths
if os.search_path.len() &gt; 0
    puts("First path:", os.search_path.first())
    puts("Last path:", os.search_path.last())
end
```quest

**Note:** Direct assignment to module members (`os.search_path = ...`) is not yet supported. The search path must be set via the `QUEST_INCLUDE` environment variable before starting Quest.

See [arrays.md](arrays.md) for available array methods: `push`, `pop`, `shift`, `unshift`, `first`, `last`, `get`, `len`.

### Example: Module Resolution

Given this search configuration:
- Current directory: `/home/user/project`
- `os.search_path`: `["/opt/quest/modules", "/usr/local/share/quest"]`

When you execute `use "utils/helper"` or `use "utils/helper" as helper`, Quest searches in order:
1. `/home/user/project/utils/helper.q`
2. `/opt/quest/modules/utils/helper.q`
3. `/usr/local/share/quest/utils/helper.q`

The first file found is loaded as the module.

### Module Not Found Error

If a module cannot be found in any search location, Quest reports an error:

```q
use "nonexistent.q" missing
# Error: Module 'nonexistent.q' not found in current directory or search paths: [/opt/quest/modules, /usr/local/share/quest]
```quest</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exception-handling"><a class="header" href="#exception-handling">Exception Handling</a></h1>
<p>Quest provides exception handling for error management and recovery using <code>try</code>, <code>catch</code>, <code>ensure</code>, and <code>raise</code> keywords.</p>
<h2 id="basic-exception-handling"><a class="header" href="#basic-exception-handling">Basic Exception Handling</a></h2>
<h3 id="try-catch-block"><a class="header" href="#try-catch-block">Try-Catch Block</a></h3>
<pre><code class="language-quest">try
    # Code that might raise an exception
    let result = risky_operation()
    puts("Success: ", result)
catch e
    # Handle the exception
    puts("Error occurred: ", e.message)
end
```quest

### Try-Catch-Ensure

The `ensure` block always executes, whether an exception occurs or not:

```quest
try
    file = io.open("data.txt", "r")
    let content = file.read()
    process(content)
catch e
    puts("Failed to read file: ", e.message)
ensure
    # Always runs, even if exception occurs
    if file != nil
        file.close()
    end
end
```quest

## Raising Exceptions

### Basic Raise

```quest
if value &lt; 0
    raise "Value cannot be negative"
end
```quest

### Raise with Exception Type

```quest
if !user.is_authenticated()
    raise AuthenticationError("User not logged in")
end

if file_size &gt; max_size
    raise ValueError("File too large: " .. file_size .. " bytes")
end
```quest

### Re-raising Exceptions

```quest
try
    dangerous_operation()
catch e
    puts("Logging error: ", e.message)
    raise  # Re-raise the same exception
end
```quest

## Multiple Catch Blocks

Handle different exception types differently:

```quest
try
    let data = json.parse(user_input)
    process_data(data)
catch e: JsonParseError
    puts("Invalid JSON format")
    return nil
catch e: ValidationError
    puts("Data validation failed: ", e.message)
    return nil
catch e: NetworkError
    puts("Network error occurred: ", e.message)
    return nil
catch e
    # Catch all other exceptions
    puts("Unexpected error: ", e.message)
    raise  # Re-raise if we don't know how to handle it
end
```quest

## Exception Object

Exception objects have the following properties:

```quest
try
    risky_function()
catch e
    puts("Type:    ", e.type)        # Exception type name
    puts("Message: ", e.message)     # Error message
    puts("Stack:   ", e.stack)       # Stack trace
    puts("Line:    ", e.line)        # Line number where error occurred
    puts("File:    ", e.file)        # File where error occurred
end
```quest

## Built-in Exception Types

### Standard Exceptions

- **Error** - Base exception type
- **TypeError** - Type mismatch or invalid type operation
- **ValueError** - Invalid value for operation
- **KeyError** - Dictionary key not found
- **IndexError** - Array index out of bounds
- **ZeroDivisionError** - Division by zero
- **FileNotFoundError** - File doesn't exist
- **PermissionError** - Insufficient permissions
- **NetworkError** - Network-related errors
- **TimeoutError** - Operation timed out
- **ParseError** - Parsing failed
- **JsonParseError** - JSON parsing failed
- **AssertionError** - Assertion failed
- **NotImplementedError** - Feature not implemented

## Custom Exceptions

Define custom exception types:

```quest
type ValidationError {
    str: message
    str: field
}

fun validate_email(email)
    if !email.contains("@")
        raise ValidationError("Invalid email format", email)
    end
end

try
    validate_email(user_input)
catch e: ValidationError
    puts("Field '", e.field, "' is invalid: ", e.message)
end
```quest

## Exception Chaining

Preserve the original exception when raising a new one:

```quest
try
    let data = load_data()
    process_data(data)
catch e: FileNotFoundError
    # Chain the original exception
    raise ProcessingError("Failed to process data", e)
end

# Later, you can inspect the chain:
catch e: ProcessingError
    puts("Error: ", e.message)
    puts("Caused by: ", e.cause.message)
end
```quest

## Pattern: Resource Management

Ensure resources are cleaned up:

```quest
fun read_file_safely(path)
    let file = nil
    try
        file = io.open(path, "r")
        return file.read()
    catch e: FileNotFoundError
        puts("File not found: ", path)
        return nil
    catch e: PermissionError
        puts("Permission denied: ", path)
        return nil
    ensure
        if file != nil
            file.close()
        end
    end
end
```quest

## Pattern: Validation with Exceptions

```quest
fun validate_user_data(data)
    if data == nil
        raise ValueError("User data cannot be nil")
    end

    if !data.has("email")
        raise ValidationError("Missing required field: email")
    end

    if !data.has("name")
        raise ValidationError("Missing required field: name")
    end

    if data.email.len() &lt; 5
        raise ValidationError("Email too short")
    end

    return true
end

try
    validate_user_data(user_input)
    save_user(user_input)
    puts("User saved successfully")
catch e: ValidationError
    puts("Validation failed: ", e.message)
    show_error_to_user(e.message)
catch e
    puts("Unexpected error: ", e.message)
    log_error(e)
end
```quest

## Pattern: Graceful Degradation

```quest
fun fetch_user_avatar(user_id)
    try
        return api.get_avatar(user_id)
    catch e: NetworkError
        puts("Network error, using default avatar")
        return default_avatar
    catch e: TimeoutError
        puts("Request timed out, using cached avatar")
        return cache.get_avatar(user_id, default_avatar)
    end
end
```quest

## Pattern: Transaction Rollback

```quest
fun transfer_funds(from_account, to_account, amount)
    let transaction = db.begin_transaction()

    try
        from_account.withdraw(amount)
        to_account.deposit(amount)
        transaction.commit()
        puts("Transfer successful")
    catch e
        transaction.rollback()
        puts("Transfer failed, rolled back: ", e.message)
        raise
    ensure
        transaction.close()
    end
end
```quest

## Pattern: Logging and Re-raising

```quest
fun critical_operation()
    try
        perform_operation()
    catch e
        # Log the error
        logger.error("Critical operation failed", {
            "error": e.message,
            "type": e.type,
            "stack": e.stack
        })

        # Send alert
        alerts.send_critical_error(e)

        # Re-raise to let caller handle it
        raise
    end
end
```quest

## Pattern: Timeout Protection

```quest
fun fetch_with_timeout(url, timeout_seconds)
    let timer = time.start_timer(timeout_seconds)

    try
        return http.get(url)
    catch e: TimeoutError
        puts("Request timed out after ", timeout_seconds, " seconds")
        return nil
    ensure
        timer.cancel()
    end
end
```quest

## Best Practices

### 1. Be Specific with Exception Types

```quest
# Bad: Too generic
try
    process_data()
catch e
    # What went wrong?
    puts("Error")
end

# Good: Handle specific cases
try
    process_data()
catch e: ValidationError
    handle_validation_error(e)
catch e: NetworkError
    handle_network_error(e)
catch e: FileNotFoundError
    handle_missing_file(e)
catch e
    # Only catch unexpected errors here
    log_unexpected_error(e)
    raise
end
```quest

### 2. Don't Swallow Exceptions Silently

```quest
# Bad: Silent failure
try
    important_operation()
catch e
    # Nothing - error disappears
end

# Good: At least log it
try
    important_operation()
catch e
    logger.error("Operation failed: ", e.message)
    # Or provide fallback behavior
end
```quest

### 3. Clean Up Resources

```quest
# Always use ensure for cleanup
try
    connection = db.connect()
    perform_queries(connection)
catch e
    puts("Database error: ", e.message)
ensure
    if connection != nil
        connection.close()
    end
end
```quest

### 4. Provide Context in Error Messages

```quest
# Bad: Vague message
raise "Invalid input"

# Good: Specific and actionable
raise ValueError("Email must contain '@' symbol, got: " .. email)
```quest

### 5. Use Exceptions for Exceptional Cases

```quest
# Bad: Using exceptions for control flow
try
    find_user(id)
catch e: NotFoundError
    # Expected case, shouldn't use exception
    create_user(id)
end

# Good: Use return values for expected cases
let user = find_user(id)
if user == nil
    user = create_user(id)
end
```quest

## Grammar Addition

To add exception handling to Quest, the following grammar rules would be added:

```quest
try_statement = {
    "try" ~ statement* ~ catch_clause+ ~ ensure_clause? ~ "end"
    | "try" ~ statement* ~ ensure_clause ~ "end"
}

catch_clause = {
    "catch" ~ identifier ~ ":" ~ type_expr ~ statement*  // catch e: TypeError
    | "catch" ~ identifier ~ statement*                   // catch e
}

ensure_clause = { "ensure" ~ statement* }

raise_statement = {
    "raise" ~ expression     // raise "error" or raise ExceptionType("message")
    | "raise"                // re-raise current exception
}
```quest
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="string-literal"><a class="header" href="#string-literal">String Literal</a></h2>
<pre><code class="language-quest">"This is a string literal"
```quest

## String Interpolation

Quest supports three styles of string formatting, inspired by Python and Rust:

### 1. F-Strings (Python-style)

Use `f"..."` prefix for automatic variable interpolation from the current scope:

```quest
let name = "Alice"
let age = 30
puts(f"Hello {name}, you are {age} years old")
# Output: Hello Alice, you are 30 years old
```quest

F-strings are the simplest form - just prefix your string with `f` and reference variables directly. Plain strings (`"..."` without the `f` prefix) do NOT interpolate - `"Hello {name}"` is a literal string containing braces.

### 2. Explicit Formatting with .fmt()

For more control, use the `.fmt()` method with positional or named arguments.

#### Positional Arguments

```quest
"Welcome to {} in room {}".fmt("Biology", 202)
# Output: Welcome to Biology in room 202

"Item {0} costs ${1:.2}".fmt("Apple", 3.5)
# Output: Item Apple costs $3.50
```quest

#### Named Arguments

**Note**: Named arguments are not yet implemented in Quest. Use positional arguments or f-strings instead.

### Format Specifiers (Rust-style)

Format specifiers control how values are displayed.

#### Number Formatting

```quest
# Decimal precision
"{:.2}".fmt(3.14159)           # 3.14
"{:.0}".fmt(3.14159)           # 3

# Hexadecimal
"{:x}".fmt(255)                # ff
"{:X}".fmt(255)                # FF
"{:#x}".fmt(255)               # 0xff

# Binary
"{:b}".fmt(10)                 # 1010
"{:#b}".fmt(10)                # 0b1010

# Octal
"{:o}".fmt(8)                  # 10
"{:#o}".fmt(8)                 # 0o10

# Scientific notation
"{:e}".fmt(1000.0)             # 1e3
"{:E}".fmt(1000.0)             # 1E3
```quest

#### Width and Alignment

```quest
# Width (minimum characters)
"{:5}".fmt("x")                # "    x" (right-aligned by default)
"{:5}".fmt(42)                 # "   42"

# Left align
"{:&lt;5}".fmt("x")               # "x    "

# Right align (explicit)
"{:&gt;5}".fmt("x")               # "    x"

# Center align
"{:^5}".fmt("x")               # "  x  "
```quest

#### Fill Characters

```quest
# Zero-padding for numbers
"{:05}".fmt(42)                # "00042"
"{:0&gt;5}".fmt(42)               # "00042"

# Custom fill character
"{:-&gt;5}".fmt("x")              # "----x"
"{:-&lt;5}".fmt("x")              # "x----"
"{:-^5}".fmt("x")              # "--x--"
```quest

#### Sign Control

```quest
# Always show sign
"{:+}".fmt(42)                 # "+42"
"{:+}".fmt(-42)                # "-42"

# Space for positive numbers
"{: }".fmt(42)                 # " 42"
"{: }".fmt(-42)                # "-42"
```quest

#### Combined Specifiers

```quest
# Width + precision
"{:8.2}".fmt(3.14159)          # "    3.14"

# Fill + align + width + precision
"{:0&gt;8.2}".fmt(3.14)           # "00003.14"

# Sign + width + precision
"{:+8.2}".fmt(3.14)            # "   +3.14"
```quest

#### Escaped Braces

To include literal braces in the output, double them:

```quest
"Use {{}} for braces".fmt()    # "Use {} for braces"
"{{name}}".fmt()               # "{name}"
"Set: {{1, 2, 3}}".fmt()       # "Set: {1, 2, 3}"
```quest

### Format Specifier Syntax

The full format syntax is:
```quest
{[argument]:[fill][align][sign][#][0][width][.precision][type]}
```quest

Where:
- `argument`: Position (0, 1, ...) or name (optional)
- `fill`: Any character (default is space)
- `align`: `&lt;` (left), `&gt;` (right), `^` (center)
- `sign`: `+` (always), `-` (negative only, default), ` ` (space for positive)
- `#`: Alternate form (0x, 0b, 0o prefixes)
- `0`: Zero-padding (shorthand for `:0&gt;`)
- `width`: Minimum width in characters
- `precision`: Number of decimal places for floats
- `type`: `x` (hex), `X` (HEX), `b` (binary), `o` (octal), `e` (scientific), `E` (SCIENTIFIC)

## String concatenation

```quest
# Evaluates as: str_literal .. obj.str() .. string_literal .. expr
# expression here evaluates to a num and num.str() is accessed to provide
# the string.
"String" .. obj .. "adf" .. (3 + 4)
```quest

## Multi-Line Strings
```quest
"""
This is a multi-line string
   Newline and indention levels are retained
But whitespace after the opening quotes 
and whitespace after the last line are ignored.
"""
```quest

## Documentation Blocks

Quest has python style documentation blocks that use multi-line string syntax

```quest
type Cat {
    """
    Soft kitty
    Warm kitty
    Little ball of fur
    """
}
puts(Cat._doc())
# Output:
# Soft kitty
# Warm kitty
# Little ball of fur
```quest

## String Methods
capitalize() Returns a new string with the first character to upper case 
count()	Returns the number of times a specified value occurs in a string
encode() Returns an encoded version of the string
endswith() Returns true if the string ends with the specified value
expandtabs() Sets the tab size of the string
isalnum()	Returns True if all characters in the string are alphanumeric
isalpha()	Returns True if all characters in the string are in the alphabet
isascii()	Returns True if all characters in the string are ascii characters
isdecimal()	Returns True if all characters in the string are decimals
isdigit()	Returns True if all characters in the string are digits
islower()	Returns True if all characters in the string are lower case
isnumeric()	Returns True if all characters in the string are numeric
isspace()	Returns True if all characters in the string are whitespaces
istitle()	Returns True if the string follows the rules of a title
isupper()	Returns True if all characters in the string are upper case
lower()	Converts a string into lower case
ltrim()	Returns a left trim version of the string
rtrim()	Returns a right trim version of the string
trim()	Returns a trimmed version of the string
title()	Converts the first character of each word to upper case
upper()	Converts a string into upper case
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrays"><a class="header" href="#arrays">Arrays</a></h1>
<p>Arrays in Quest are ordered collections of values. Arrays are immutable by default - methods that modify arrays return new arrays rather than mutating the original.</p>
<h2 id="array-literals"><a class="header" href="#array-literals">Array Literals</a></h2>
<pre><code class="language-q">let empty = []
let numbers = [1, 2, 3, 4, 5]
let mixed = [1, "hello", true, nil]
let nested = [[1, 2], [3, 4], [5, 6]]
```quest

## Array Methods

### `len()`
Returns the number of elements in the array

**Returns:** Num

**Example:**
```q
let arr = [1, 2, 3, 4]
puts(arr.len())  # 4
```quest

### `push(value)`
Returns a new array with the value added to the end

**Parameters:**
- `value` - Value to add (any type)

**Returns:** Array (new array with element added)

**Example:**
```q
let arr = [1, 2, 3]
let arr2 = arr.push(4)
puts(arr)   # [1, 2, 3]
puts(arr2)  # [1, 2, 3, 4]
```quest

### `pop()`
Returns a new array with the last element removed

**Returns:** Array (new array without last element)

**Raises:** Error if array is empty

**Example:**
```q
let arr = [1, 2, 3, 4]
let arr2 = arr.pop()
puts(arr)   # [1, 2, 3, 4]
puts(arr2)  # [1, 2, 3]
```quest

### `shift()`
Returns a new array with the first element removed

**Returns:** Array (new array without first element)

**Raises:** Error if array is empty

**Example:**
```q
let arr = [1, 2, 3, 4]
let arr2 = arr.shift()
puts(arr)   # [1, 2, 3, 4]
puts(arr2)  # [2, 3, 4]
```quest

### `unshift(value)`
Returns a new array with the value added to the beginning

**Parameters:**
- `value` - Value to add (any type)

**Returns:** Array (new array with element prepended)

**Example:**
```q
let arr = [2, 3, 4]
let arr2 = arr.unshift(1)
puts(arr)   # [2, 3, 4]
puts(arr2)  # [1, 2, 3, 4]
```quest

### `get(index)`
Returns the element at the specified index

**Parameters:**
- `index` - Zero-based index (Num)

**Returns:** Element at index

**Raises:** Error if index out of bounds

**Example:**
```q
let arr = ["a", "b", "c"]
puts(arr.get(0))  # a
puts(arr.get(1))  # b
puts(arr.get(2))  # c
```quest

### `first()`
Returns the first element of the array

**Returns:** First element

**Raises:** Error if array is empty

**Example:**
```q
let arr = [10, 20, 30]
puts(arr.first())  # 10
```quest

### `last()`
Returns the last element of the array

**Returns:** Last element

**Raises:** Error if array is empty

**Example:**
```q
let arr = [10, 20, 30]
puts(arr.last())  # 30
```quest

## Array Access with `[]`

Arrays can be accessed using bracket notation:

```q
let arr = [10, 20, 30, 40]
puts(arr[0])   # 10
puts(arr[1])   # 20
puts(arr[3])   # 40
```quest

## Immutability Pattern

Since arrays are immutable in expressions, use reassignment to "update" an array:

```q
let arr = [1, 2, 3]

# Add element
arr = arr.push(4)
puts(arr)  # [1, 2, 3, 4]

# Remove last element
arr = arr.pop()
puts(arr)  # [1, 2, 3]

# Add to beginning
arr = arr.unshift(0)
puts(arr)  # [0, 1, 2, 3]

# Remove from beginning
arr = arr.shift()
puts(arr)  # [1, 2, 3]
```quest

## Common Patterns

### Building Arrays

```q
let arr = []
arr = arr.push(1)
arr = arr.push(2)
arr = arr.push(3)
puts(arr)  # [1, 2, 3]
```quest

### Stack Operations (LIFO)

```q
let stack = []

# Push items
stack = stack.push("first")
stack = stack.push("second")
stack = stack.push("third")

# Pop items (returns new array)
let item = stack.last()  # Get top item
stack = stack.pop()      # Remove it
puts(item)  # third
```quest

### Queue Operations (FIFO)

```q
let queue = []

# Enqueue (add to end)
queue = queue.push("first")
queue = queue.push("second")
queue = queue.push("third")

# Dequeue (remove from front)
let item = queue.first()  # Get front item
queue = queue.shift()     # Remove it
puts(item)  # first
```quest

### Checking Array Contents

```q
let arr = [1, 2, 3, 4, 5]

# Check if empty
if arr.len() == 0
    puts("Array is empty")
end

# Get first and last
if arr.len() &gt; 0
    puts("First:", arr.first())
    puts("Last:", arr.last())
end

# Safe access
if arr.len() &gt; 2
    puts("Third element:", arr.get(2))
end
```quest

### Array Transformation

```q
# Build a new array based on another
let numbers = [1, 2, 3, 4, 5]
let evens = []

# Filter evens (when iteration is implemented)
# for num in numbers
#     if num % 2 == 0
#         evens = evens.push(num)
#     end
# end
```quest

## Notes

- Arrays are **zero-indexed** (first element is at index 0)
- Arrays are **heterogeneous** (can contain mixed types)
- Arrays are **immutable** in expressions (methods return new arrays)
- Use reassignment (`arr = arr.push(x)`) to update array variables
- Out-of-bounds access raises an error
- Empty array operations (pop/shift/first/last on `[]`) raise errors
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-library"><a class="header" href="#standard-library">Standard Library</a></h1>
<p>Quest includes a carefully curated standard library with modules for common tasks.</p>
<h2 id="importing-modules"><a class="header" href="#importing-modules">Importing Modules</a></h2>
<p>Use the <code>use</code> statement to import modules:</p>
<pre><code class="language-quest">use "std/math" as math
puts(math.pi)  # 3.141592653589793
```quest

## Available Modules

### Mathematics and Numerics

- **[math](./math.md)** - Mathematical functions (sin, cos, sqrt, etc.) and constants (pi, e)

### String Processing

- **[str](./str.md)** - String manipulation utilities

### Data Formats

- **[json](./json.md)** - JSON encoding and decoding
- **[b64](./b64.md)** - Base64 encoding and decoding
- **[hash](./hash.md)** - Cryptographic hash functions (MD5, SHA1, SHA256, SHA512)

### Input/Output

- **[io](./io.md)** - File and stream I/O operations

### System Integration

- **[sys](./sys.md)** - System information and command-line arguments
- **[os](./os.md)** - Operating system interfaces
- **[time](./time.md)** - Date and time operations

### Terminal

- **[term](./term.md)** - Terminal colors and text formatting

### Development

- **[test](./test.md)** - Unit testing framework

## Module Usage Patterns

### Basic Import

```quest
use "std/math" as math
let result = math.sqrt(16)  # 4
```quest

### Multiple Imports

```quest
use "std/json" as json
use "std/io" as io

let data = {"name": "Quest", "version": "1.0"}
let text = json.stringify(data)
io.write_file("data.json", text)
```quest

### Module Members

Modules can contain:
- **Functions**: Callable operations
- **Constants**: Read-only values (like `math.pi`)

Access members using dot notation:

```quest
use "std/math" as m

puts(m.pi)           # Constant
puts(m.sin(m.pi))    # Function call
```quest

## Creating Your Own Modules

Quest modules are simply `.q` files that export values:

```quest
# mymodule.q
let version = "1.0"

fun greet(name)
    "Hello, " .. name
end

# Export by having them in scope
```quest

Import your module:

```quest
use "mymodule" as mine
puts(mine.greet("World"))
```quest

See [Modules](../language/modules.md) for more details on creating and organizing modules.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="math-module"><a class="header" href="#math-module">Math Module</a></h1>
<p>The <code>math</code> module provides mathematical constants and functions.</p>
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<h3 id="mathpi"><a class="header" href="#mathpi"><code>math.pi</code></a></h3>
<p>Value of À (pi) - approximately 3.14159265359</p>
<h3 id="mathtau"><a class="header" href="#mathtau"><code>math.tau</code></a></h3>
<p>Value of Ä (tau) - approximately 6.28318530718 (equal to 2À)</p>
<h2 id="trigonometric-functions"><a class="header" href="#trigonometric-functions">Trigonometric Functions</a></h2>
<h3 id="mathsinn"><a class="header" href="#mathsinn"><code>math.sin(n)</code></a></h3>
<p>Calculate sine of angle in radians</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>n</code> - Angle in radians (Num)</li>
</ul>
<p><strong>Returns:</strong> Num</p>
<p><strong>Example:</strong></p>
<pre><code class="language-quest">math.sin(math.pi / 2)  # Returns 1.0
```quest

### `math.cos(n)`
Calculate cosine of angle in radians

**Parameters:**
- `n` - Angle in radians (Num)

**Returns:** Num

**Example:**
```quest
math.cos(0)  # Returns 1.0
```quest

### `math.tan(n)`
Calculate tangent of angle in radians

**Parameters:**
- `n` - Angle in radians (Num)

**Returns:** Num

### `math.asin(n)`
Calculate arcsine (inverse sine)

**Parameters:**
- `n` - Value between -1 and 1 (Num)

**Returns:** Angle in radians (Num)

### `math.acos(n)`
Calculate arccosine (inverse cosine)

**Parameters:**
- `n` - Value between -1 and 1 (Num)

**Returns:** Angle in radians (Num)

### `math.atan(n)`
Calculate arctangent (inverse tangent)

**Parameters:**
- `n` - Value (Num)

**Returns:** Angle in radians (Num)

## Other Math Functions

### `math.abs(n)`
Calculate absolute value

**Parameters:**
- `n` - Number (Num)

**Returns:** Absolute value (Num)

**Example:**
```quest
math.abs(-5)  # Returns 5
```quest

### `math.sqrt(n)`
Calculate square root

**Parameters:**
- `n` - Non-negative number (Num)

**Returns:** Square root (Num)

**Example:**
```quest
math.sqrt(16)  # Returns 4
```quest

### `math.ln(n)`
Calculate natural logarithm (base e)

**Parameters:**
- `n` - Positive number (Num)

**Returns:** Natural logarithm (Num)

### `math.log10(n)`
Calculate logarithm base 10

**Parameters:**
- `n` - Positive number (Num)

**Returns:** Base-10 logarithm (Num)

### `math.exp(n)`
Calculate e raised to the power

**Parameters:**
- `n` - Exponent (Num)

**Returns:** e^n (Num)

### `math.floor(n)`
Round down to nearest integer

**Parameters:**
- `n` - Number (Num)

**Returns:** Largest integer less than or equal to n (Num)

**Example:**
```quest
math.floor(3.7)  # Returns 3
```quest

### `math.ceil(n)`
Round up to nearest integer

**Parameters:**
- `n` - Number (Num)

**Returns:** Smallest integer greater than or equal to n (Num)

**Example:**
```quest
math.ceil(3.2)  # Returns 4
```quest

### `math.round(n)`
Round to nearest integer

**Parameters:**
- `n` - Number (Num)

**Returns:** Nearest integer (Num)

**Example:**
```quest
math.round(3.5)  # Returns 4
math.round(3.4)  # Returns 3
```quest
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>let name = "Steven"
let year = 2005
format("Hello {name}, the year is {year}")</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io-module"><a class="header" href="#io-module">IO Module</a></h1>
<p>The <code>io</code> module provides file and stream input/output operations.</p>
<h2 id="file-reading"><a class="header" href="#file-reading">File Reading</a></h2>
<h3 id="ioreadpath"><a class="header" href="#ioreadpath"><code>io.read(path)</code></a></h3>
<p>Read entire file contents as a string</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>path</code> - File path (Str)</li>
</ul>
<p><strong>Returns:</strong> File contents (Str)</p>
<p><strong>Raises:</strong> Error if file doesn't exist or can't be read</p>
<p><strong>Example:</strong></p>
<pre><code class="language-quest">let content = io.read("data.txt")
puts(content)
```quest

### `io.read_lines(path)`
Read file as list of lines (with newlines stripped)

**Parameters:**
- `path` - File path (Str)

**Returns:** List of lines (List of Str)

**Example:**
```quest
let lines = io.read_lines("input.txt")
for line in lines
    puts(line)
end
```quest

### `io.read_bytes(path)`
Read file as raw bytes

**Parameters:**
- `path` - File path (Str)

**Returns:** Byte array (Bytes)

**Example:**
```quest
let data = io.read_bytes("image.png")
```quest

## File Writing

### `io.write(path, content)`
Write string to file (overwrites existing content)

**Parameters:**
- `path` - File path (Str)
- `content` - Content to write (Str)

**Returns:** Nil

**Example:**
```quest
io.write("output.txt", "Hello, World!")
```quest

### `io.write_lines(path, lines)`
Write list of strings to file (adds newlines)

**Parameters:**
- `path` - File path (Str)
- `lines` - List of strings (List)

**Returns:** Nil

**Example:**
```quest
let lines = ["First line", "Second line", "Third line"]
io.write_lines("output.txt", lines)
```quest

### `io.write_bytes(path, bytes)`
Write raw bytes to file

**Parameters:**
- `path` - File path (Str)
- `bytes` - Byte data (Bytes)

**Returns:** Nil

### `io.append(path, content)`
Append string to file (creates if doesn't exist)

**Parameters:**
- `path` - File path (Str)
- `content` - Content to append (Str)

**Returns:** Nil

**Example:**
```quest
io.append("log.txt", "New log entry\n")
```quest

## File Operations

### `io.exists(path)`
Check if file or directory exists

**Parameters:**
- `path` - File or directory path (Str)

**Returns:** Bool (true if exists)

**Example:**
```quest
if io.exists("config.json")
    let config = io.read("config.json")
end
```quest

### `io.is_file(path)`
Check if path is a file

**Parameters:**
- `path` - Path (Str)

**Returns:** Bool

### `io.is_dir(path)`
Check if path is a directory

**Parameters:**
- `path` - Path (Str)

**Returns:** Bool

### `io.size(path)`
Get file size in bytes

**Parameters:**
- `path` - File path (Str)

**Returns:** Size in bytes (Num)

**Example:**
```quest
let size = io.size("large_file.dat")
puts("File is ", size, " bytes")
```quest

### `io.copy(src, dst)`
Copy file from source to destination

**Parameters:**
- `src` - Source file path (Str)
- `dst` - Destination file path (Str)

**Returns:** Nil

**Example:**
```quest
io.copy("original.txt", "backup.txt")
```quest

### `io.move(src, dst)`
Move/rename file

**Parameters:**
- `src` - Source file path (Str)
- `dst` - Destination file path (Str)

**Returns:** Nil

### `io.remove(path)`
Delete file

**Parameters:**
- `path` - File path (Str)

**Returns:** Nil

**Example:**
```quest
if io.exists("temp.txt")
    io.remove("temp.txt")
end
```quest

## Directory Operations

### `io.mkdir(path)`
Create directory (fails if parent doesn't exist)

**Parameters:**
- `path` - Directory path (Str)

**Returns:** Nil

### `io.mkdir_all(path)`
Create directory and all parent directories

**Parameters:**
- `path` - Directory path (Str)

**Returns:** Nil

**Example:**
```quest
io.mkdir_all("data/outputs/2024")
```quest

### `io.rmdir(path)`
Remove empty directory

**Parameters:**
- `path` - Directory path (Str)

**Returns:** Nil

### `io.rmdir_all(path)`
Remove directory and all contents recursively

**Parameters:**
- `path` - Directory path (Str)

**Returns:** Nil

**Warning:** Use with caution - permanently deletes all contents

### `io.list_dir(path)`
List files and directories in path

**Parameters:**
- `path` - Directory path (Str)

**Returns:** List of names (List of Str)

**Example:**
```quest
let files = io.list_dir(".")
for file in files
    puts(file)
end
```quest

### `io.walk(path)`
Recursively walk directory tree

**Parameters:**
- `path` - Root directory path (Str)

**Returns:** List of all file paths (List of Str)

**Example:**
```quest
let all_files = io.walk("src")
for file in all_files
    if file.endswith(".q")
        puts(file)
    end
end
```quest

## File Metadata

### `io.modified_time(path)`
Get last modification time as Unix timestamp

**Parameters:**
- `path` - File path (Str)

**Returns:** Unix timestamp (Num)

### `io.created_time(path)`
Get creation time as Unix timestamp

**Parameters:**
- `path` - File path (Str)

**Returns:** Unix timestamp (Num)

### `io.accessed_time(path)`
Get last access time as Unix timestamp

**Parameters:**
- `path` - File path (Str)

**Returns:** Unix timestamp (Num)

## Path Utilities

### `io.absolute(path)`
Convert relative path to absolute path

**Parameters:**
- `path` - Relative or absolute path (Str)

**Returns:** Absolute path (Str)

**Example:**
```quest
let abs = io.absolute("../data/file.txt")
puts(abs)  # /Users/name/project/data/file.txt
```quest

### `io.basename(path)`
Get filename from path

**Parameters:**
- `path` - File path (Str)

**Returns:** Filename (Str)

**Example:**
```quest
io.basename("/path/to/file.txt")  # Returns "file.txt"
```quest

### `io.dirname(path)`
Get directory from path

**Parameters:**
- `path` - File path (Str)

**Returns:** Directory path (Str)

**Example:**
```quest
io.dirname("/path/to/file.txt")  # Returns "/path/to"
```quest

### `io.extension(path)`
Get file extension

**Parameters:**
- `path` - File path (Str)

**Returns:** Extension including dot (Str) or empty string

**Example:**
```quest
io.extension("file.txt")  # Returns ".txt"
io.extension("archive.tar.gz")  # Returns ".gz"
```quest

### `io.join(parts...)`
Join path components with appropriate separator

**Parameters:**
- `parts...` - Path components (Str)

**Returns:** Joined path (Str)

**Example:**
```quest
let path = io.join("data", "outputs", "results.csv")
# Returns "data/outputs/results.csv" on Unix
# Returns "data\outputs\results.csv" on Windows
```quest

## Glob/Pattern Matching

### `io.glob(pattern)`
Find all files matching a glob pattern

**Parameters:**
- `pattern` - Glob pattern (Str)
  - `*` matches any characters except `/`
  - `**` matches any characters including `/` (recursive)
  - `?` matches single character
  - `[abc]` matches one character from set
  - `[!abc]` matches one character not in set

**Returns:** List of matching file paths (List of Str)

**Example:**
```quest
# Find all .q files in current directory
let quest_files = io.glob("*.q")

# Find all .txt files recursively
let all_text = io.glob("**/*.txt")

# Find all test files
let tests = io.glob("test_*.q")

# Multiple patterns
let sources = io.glob("src/**/*.{q,md}")
```quest

### `io.glob_match(path, pattern)`
Check if a path matches a glob pattern

**Parameters:**
- `path` - File path to test (Str)
- `pattern` - Glob pattern (Str)

**Returns:** Bool (true if matches)

**Example:**
```quest
if io.glob_match("test_utils.q", "test_*.q")
    puts("This is a test file")
end
```quest

## Stream/Handle Operations

### `io.open(path, mode = "r")`
Open file and return file handle

**Parameters:**
- `path` - File path (Str)
- `mode` - Open mode (Str): "r" (read), "w" (write), "a" (append), "r+" (read/write)

**Returns:** File handle (File)

**Example:**
```quest
let f = io.open("data.txt", "r")
let content = f.read()
f.close()
```quest

### File Handle Methods

#### `file.read()`
Read entire file contents

**Returns:** File contents (Str)

#### `file.read_line()`
Read single line (returns nil at EOF)

**Returns:** Line string or Nil

#### `file.write(content)`
Write string to file

**Parameters:**
- `content` - String to write (Str)

#### `file.flush()`
Flush write buffer to disk

#### `file.close()`
Close file handle

#### `file.seek(position)`
Seek to position in file

**Parameters:**
- `position` - Byte offset (Num)

#### `file.tell()`
Get current position in file

**Returns:** Byte offset (Num)

### `io.with_file(path, mode, fn)`
Open file, execute function, automatically close

**Parameters:**
- `path` - File path (Str)
- `mode` - Open mode (Str)
- `fn` - Function to execute with file handle

**Returns:** Result of function

**Example:**
```quest
io.with_file("output.txt", "w", fun(f)
    f.write("Line 1\n")
    f.write("Line 2\n")
end)
```quest

## Standard Streams

### `io.stdin`
Standard input stream (File handle)

### `io.stdout`
Standard output stream (File handle)

### `io.stderr`
Standard error stream (File handle)

**Example:**
```quest
io.stderr.write("Error: something went wrong\n")
```quest

### `io.read_line()`
Read line from standard input

**Returns:** Input line (Str)

**Example:**
```quest
print("Enter your name: ")
let name = io.read_line()
puts("Hello, ", name, "!")
```quest

## Temporary Files

### `io.temp_file(prefix = "quest")`
Create temporary file

**Parameters:**
- `prefix` - Filename prefix (Str)

**Returns:** File handle to temp file (File)

### `io.temp_dir(prefix = "quest")`
Create temporary directory

**Parameters:**
- `prefix` - Directory name prefix (Str)

**Returns:** Path to temp directory (Str)

## Common Patterns

### Reading and Processing Lines
```quest
let lines = io.read_lines("input.txt")
let results = []

for line in lines
    if !line.startswith("#")  # Skip comments
        results.append(line.trim())
    end
end

io.write_lines("output.txt", results)
```quest

### Safe File Writing
```quest
io.with_file("config.json", "w", fun(f)
    f.write("{")
    f.write("  \"version\": 1,")
    f.write("  \"enabled\": true")
    f.write("}")
end)
```quest

### Directory Traversal
```quest
let quest_files = []
for file in io.walk("src")
    if io.extension(file) == ".q"
        quest_files.append(file)
    end
end
puts("Found ", quest_files.len(), " Quest files")
```quest

### File Size Check
```quest
if io.exists("large_file.dat") and io.size("large_file.dat") &gt; 1000000
    puts("Warning: File is larger than 1MB")
end
```quest
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-module"><a class="header" href="#json-module">JSON Module</a></h1>
<p>The <code>json</code> module provides JSON parsing and serialization functionality.</p>
<h2 id="parsing"><a class="header" href="#parsing">Parsing</a></h2>
<h3 id="jsonparsetext"><a class="header" href="#jsonparsetext"><code>json.parse(text)</code></a></h3>
<p>Parse JSON string into Quest object</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>text</code> - JSON string (Str)</li>
</ul>
<p><strong>Returns:</strong> Parsed value (Num, Str, Bool, Nil, List, or Dict)</p>
<p><strong>Raises:</strong> Error if invalid JSON</p>
<p><strong>Example:</strong></p>
<pre><code class="language-quest">let data = json.parse('{"name": "Alice", "age": 30}')
puts(data.name)  # Alice
puts(data.age)   # 30
```quest

### `json.parse_file(path)`
Parse JSON from file

**Parameters:**
- `path` - File path (Str)

**Returns:** Parsed JSON value

**Example:**
```quest
let config = json.parse_file("config.json")
puts("Host: ", config.host)
puts("Port: ", config.port)
```quest

### `json.try_parse(text)`
Try to parse JSON, return nil on error instead of raising

**Parameters:**
- `text` - JSON string (Str)

**Returns:** Parsed value or Nil if invalid

**Example:**
```quest
let result = json.try_parse(user_input)
if result == nil
    puts("Invalid JSON")
else
    puts("Parsed successfully")
end
```quest

## Serialization

### `json.stringify(value, pretty = false)`
Convert Quest value to JSON string

**Parameters:**
- `value` - Value to serialize (Num, Str, Bool, Nil, List, or Dict)
- `pretty` - Pretty print with indentation (Bool, default false)

**Returns:** JSON string (Str)

**Example:**
```quest
let data = {"name": "Bob", "scores": [95, 87, 92]}
let json_str = json.stringify(data)
puts(json_str)  # {"name":"Bob","scores":[95,87,92]}
```quest

### `json.stringify_pretty(value, indent = 2)`
Convert Quest value to pretty-printed JSON

**Parameters:**
- `value` - Value to serialize
- `indent` - Number of spaces for indentation (Num, default 2)

**Returns:** Formatted JSON string (Str)

**Example:**
```quest
let data = {"name": "Bob", "scores": [95, 87, 92]}
let json_str = json.stringify_pretty(data)
puts(json_str)
# Output:
# {
#   "name": "Bob",
#   "scores": [
#     95,
#     87,
#     92
#   ]
# }
```quest

### `json.to_file(value, path, pretty = false)`
Serialize value and write to file

**Parameters:**
- `value` - Value to serialize
- `path` - File path (Str)
- `pretty` - Pretty print (Bool, default false)

**Returns:** Nil

**Example:**
```quest
let config = {"host": "localhost", "port": 8080, "debug": true}
json.to_file(config, "config.json", true)
```quest

## Validation

### `json.is_valid(text)`
Check if string is valid JSON

**Parameters:**
- `text` - String to validate (Str)

**Returns:** Bool (true if valid JSON)

**Example:**
```quest
let input = io.read_line()
if json.is_valid(input)
    let data = json.parse(input)
    process(data)
else
    puts("Error: Invalid JSON format")
end
```quest

## Type Checking

### `json.is_object(value)`
Check if parsed JSON value is an object (Dict)

**Parameters:**
- `value` - Parsed JSON value

**Returns:** Bool

### `json.is_array(value)`
Check if parsed JSON value is an array (List)

**Parameters:**
- `value` - Parsed JSON value

**Returns:** Bool

**Example:**
```quest
let data = json.parse(input)

if json.is_array(data)
    for item in data
        puts(item)
    end
elif json.is_object(data)
    for key in data.keys()
        puts(key, ": ", data[key])
    end
end
```quest

## Path Access (JSON Pointer)

### `json.get(data, path, default = nil)`
Get value at JSON path

**Parameters:**
- `data` - Parsed JSON object
- `path` - Dot-separated path (Str) e.g., "user.address.city"
- `default` - Default value if path not found (default nil)

**Returns:** Value at path or default

**Example:**
```quest
let data = json.parse('{"user": {"name": "Alice", "address": {"city": "NYC"}}}')
let city = json.get(data, "user.address.city")
puts(city)  # NYC

let unknown = json.get(data, "user.age", 0)
puts(unknown)  # 0 (default)
```quest

### `json.set(data, path, value)`
Set value at JSON path

**Parameters:**
- `data` - Parsed JSON object (Dict)
- `path` - Dot-separated path (Str)
- `value` - Value to set

**Returns:** Modified data object

**Example:**
```quest
let data = {"user": {"name": "Alice"}}
json.set(data, "user.age", 30)
json.set(data, "user.address.city", "NYC")
puts(json.stringify_pretty(data))
```quest

### `json.has(data, path)`
Check if path exists in JSON object

**Parameters:**
- `data` - Parsed JSON object
- `path` - Dot-separated path (Str)

**Returns:** Bool (true if path exists)

**Example:**
```quest
let data = json.parse_file("config.json")
if json.has(data, "database.host")
    let host = json.get(data, "database.host")
    puts("Connecting to: ", host)
else
    puts("Database configuration missing")
end
```quest

## Merging

### `json.merge(obj1, obj2, deep = false)`
Merge two JSON objects

**Parameters:**
- `obj1` - First object (Dict)
- `obj2` - Second object (Dict)
- `deep` - Deep merge nested objects (Bool, default false)

**Returns:** Merged object (Dict)

**Example:**
```quest
let defaults = {"host": "localhost", "port": 8080, "timeout": 30}
let config = {"host": "example.com", "debug": true}
let merged = json.merge(defaults, config)
puts(json.stringify_pretty(merged))
# {
#   "host": "example.com",
#   "port": 8080,
#   "timeout": 30,
#   "debug": true
# }
```quest

## Schema Validation

### `json.validate(data, schema)`
Validate JSON data against schema

**Parameters:**
- `data` - Parsed JSON value
- `schema` - Schema definition (Dict)

**Returns:** Bool (true if valid)

**Example:**
```quest
let schema = {
    "type": "object",
    "properties": {
        "name": {"type": "string"},
        "age": {"type": "number"}
    },
    "required": ["name"]
}

let data = {"name": "Alice", "age": 30}
if json.validate(data, schema)
    puts("Valid data")
else
    puts("Invalid data")
end
```quest

## Common Use Cases

### Configuration Files
```quest
# Load configuration
let config = json.parse_file("config.json")
let host = json.get(config, "database.host", "localhost")
let port = json.get(config, "database.port", 5432)

# Update and save configuration
json.set(config, "last_updated", time.now())
json.to_file(config, "config.json", true)
```quest

### API Requests/Responses
```quest
# Make API request
let request_body = json.stringify({
    "action": "create_user",
    "data": {"name": "Alice", "email": "alice@example.com"}
})

let response = http.post("https://api.example.com/users", request_body)
let result = json.parse(response.body)

if result.success
    puts("User created with ID: ", result.user_id)
else
    puts("Error: ", result.error)
end
```quest

### Data Processing
```quest
# Load and process JSON data
let users = json.parse_file("users.json")
let active_users = []

for user in users
    if user.active
        active_users.append(user)
    end
end

json.to_file(active_users, "active_users.json", true)
```quest

### Logging
```quest
# Structured JSON logging
let log_entry = {
    "timestamp": time.now(),
    "level": "ERROR",
    "message": "Connection failed",
    "details": {
        "host": "db.example.com",
        "error": "timeout"
    }
}

let log_line = json.stringify(log_entry)
io.append("logs/app.log", log_line + "\n")
```quest

### Data Validation
```quest
# Validate user input
let user_input = io.read("user_data.json")
let data = json.try_parse(user_input)

if data == nil
    puts("Error: Invalid JSON format")
    return
end

if !json.has(data, "email") or !json.has(data, "name")
    puts("Error: Missing required fields")
    return
end

# Process valid data
puts("Processing user: ", data.name)
```quest

### Nested Data Access
```quest
# Access deeply nested data safely
let response = json.parse_file("api_response.json")

let city = json.get(response, "data.user.address.city", "Unknown")
let zip = json.get(response, "data.user.address.zip", "00000")

puts("Location: ", city, " ", zip)
```quest

### Data Export
```quest
# Export data to JSON
let results = [
    {"id": 1, "name": "Alice", "score": 95},
    {"id": 2, "name": "Bob", "score": 87},
    {"id": 3, "name": "Carol", "score": 92}
]

json.to_file(results, "results.json", true)
puts("Exported ", results.len(), " records")
```quest
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hash-module"><a class="header" href="#hash-module">Hash Module</a></h1>
<p>The <code>hash</code> module provides cryptographic and non-cryptographic hashing functions.</p>
<h2 id="cryptographic-hash-functions"><a class="header" href="#cryptographic-hash-functions">Cryptographic Hash Functions</a></h2>
<h3 id="hashmd5data"><a class="header" href="#hashmd5data"><code>hash.md5(data)</code></a></h3>
<p>Calculate MD5 hash (128-bit)</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>data</code> - Data to hash (Str or Bytes)</li>
</ul>
<p><strong>Returns:</strong> Hex string of hash (Str)</p>
<p><strong>Note:</strong> MD5 is not cryptographically secure. Use for checksums only, not security.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-quest">let h = hash.md5("Hello, World!")
puts(h)  # 8cda2aacb2e63f99d416d3e4d82e3295
```quest

### `hash.sha1(data)`
Calculate SHA-1 hash (160-bit)

**Parameters:**
- `data` - Data to hash (Str or Bytes)

**Returns:** Hex string of hash (Str)

**Note:** SHA-1 is deprecated for security purposes. Use SHA-256 or better.

**Example:**
```quest
let h = hash.sha1("Hello, World!")
puts(h)  # 4ca9653095931ef15cb6b02d72f621e1bcbb856b
```quest

### `hash.sha256(data)`
Calculate SHA-256 hash (256-bit)

**Parameters:**
- `data` - Data to hash (Str or Bytes)

**Returns:** Hex string of hash (Str)

**Example:**
```quest
let h = hash.sha256("Hello, World!")
puts(h)  # ae97eca8f8ae1672bcc5c79e3fbafd8ee86f65f775e2250a291d3788b7a8af95
```quest

### `hash.sha512(data)`
Calculate SHA-512 hash (512-bit)

**Parameters:**
- `data` - Data to hash (Str or Bytes)

**Returns:** Hex string of hash (Str)

**Example:**
```quest
let h = hash.sha512("Hello, World!")
puts(h)  # da73ffa8c95e8f252951e3e2a21062f53ad8fc3a977da67f627c20fc2c13949f1be4fa07beed0383e79767b205c42b9f947938ba4d9eea0c8e88bf912f526011
```quest

## HMAC (Hash-based Message Authentication Code)

### `hash.hmac_sha256(data, key)`
Calculate HMAC-SHA256

**Parameters:**
- `data` - Data to authenticate (Str or Bytes)
- `key` - Secret key (Str or Bytes)

**Returns:** Hex string of HMAC (Str)

**Example:**
```quest
let secret = "my_secret_key"
let message = "Hello, World!"
let hmac = hash.hmac_sha256(message, secret)
puts(hmac)
```quest

### `hash.hmac_sha512(data, key)`
Calculate HMAC-SHA512

**Parameters:**
- `data` - Data to authenticate (Str or Bytes)
- `key` - Secret key (Str or Bytes)

**Returns:** Hex string of HMAC (Str)

## Non-Cryptographic Hash Functions

### `hash.crc32(data)`
Calculate CRC32 checksum

**Parameters:**
- `data` - Data to checksum (Str or Bytes)

**Returns:** CRC32 value (Num)

**Example:**
```quest
let checksum = hash.crc32("Hello, World!")
puts(checksum)  # 2193973375
```quest

## Password Hashing

### `hash.bcrypt(password, cost = 10)`
Hash password using bcrypt

**Parameters:**
- `password` - Password to hash (Str)
- `cost` - Cost factor 4-31 (Num, default 10, higher = slower/more secure)

**Returns:** Bcrypt hash string (Str)

**Example:**
```quest
let hashed = hash.bcrypt("user_password123")
io.write("password.hash", hashed)
```quest

### `hash.bcrypt_verify(password, hash)`
Verify password against bcrypt hash

**Parameters:**
- `password` - Password to verify (Str)
- `hash` - Bcrypt hash to check against (Str)

**Returns:** Bool (true if password matches)

**Example:**
```quest
let stored_hash = io.read("password.hash")
let password = io.read_line()

if hash.bcrypt_verify(password, stored_hash)
    puts("Password correct")
else
    puts("Password incorrect")
end
```quest

## Common Use Cases

### Password Storage
```quest
# Register user
let password = io.read_line()
let hashed = hash.bcrypt(password, 12)
io.write("users/alice.hash", hashed)

# Login verification
let input_password = io.read_line()
let stored_hash = io.read("users/alice.hash")

if hash.bcrypt_verify(input_password, stored_hash)
    puts("Login successful")
else
    puts("Invalid password")
end
```quest

### API Request Signing
```quest
# Sign API request with HMAC
let api_key = "secret_api_key"
let request_body = json.stringify({"action": "transfer", "amount": 100})
let signature = hash.hmac_sha256(request_body, api_key)

# Send request with signature
http.post("https://api.example.com/action", {
    "body": request_body,
    "headers": {"X-Signature": signature}
})
```quest</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="b64-module"><a class="header" href="#b64-module">B64 Module</a></h1>
<p>The <code>b64</code> module provides Base64 encoding and decoding functionality.</p>
<h2 id="encoding"><a class="header" href="#encoding">Encoding</a></h2>
<h3 id="b64encodedata"><a class="header" href="#b64encodedata"><code>b64.encode(data)</code></a></h3>
<p>Encode data to Base64 string</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>data</code> - String or bytes to encode (Str or Bytes)</li>
</ul>
<p><strong>Returns:</strong> Base64 encoded string (Str)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-quest">let encoded = b64.encode("Hello, World!")
puts(encoded)  # SGVsbG8sIFdvcmxkIQ==
```quest

### `b64.encode_url(data)`
Encode data to URL-safe Base64 string (uses `-` and `_` instead of `+` and `/`)

**Parameters:**
- `data` - String or bytes to encode (Str or Bytes)

**Returns:** URL-safe Base64 encoded string (Str)

**Example:**
```quest
let encoded = b64.encode_url("test+data/here")
puts(encoded)  # dGVzdCtkYXRhL2hlcmU=
```quest

### `b64.encode_no_pad(data)`
Encode data to Base64 without padding (`=` characters)

**Parameters:**
- `data` - String or bytes to encode (Str or Bytes)

**Returns:** Base64 encoded string without padding (Str)

**Example:**
```quest
let encoded = b64.encode_no_pad("Hello")
puts(encoded)  # SGVsbG8
```quest

## Decoding

### `b64.decode(encoded)`
Decode Base64 string to original data

**Parameters:**
- `encoded` - Base64 encoded string (Str)

**Returns:** Decoded string (Str)

**Raises:** Error if invalid Base64 string

**Example:**
```quest
let decoded = b64.decode("SGVsbG8sIFdvcmxkIQ==")
puts(decoded)  # Hello, World!
```quest

### `b64.decode_url(encoded)`
Decode URL-safe Base64 string

**Parameters:**
- `encoded` - URL-safe Base64 encoded string (Str)

**Returns:** Decoded string (Str)

**Example:**
```quest
let decoded = b64.decode_url("dGVzdCtkYXRhL2hlcmU=")
puts(decoded)  # test+data/here
```quest

### `b64.decode_bytes(encoded)`
Decode Base64 string to raw bytes

**Parameters:**
- `encoded` - Base64 encoded string (Str)

**Returns:** Decoded bytes (Bytes)

**Example:**
```quest
let bytes = b64.decode_bytes("SGVsbG8=")
# Returns raw byte array
```quest

## Validation

### `b64.is_valid(encoded)`
Check if string is valid Base64

**Parameters:**
- `encoded` - String to validate (Str)

**Returns:** Bool (true if valid Base64)

**Example:**
```quest
if b64.is_valid(user_input)
    let decoded = b64.decode(user_input)
    puts(decoded)
else
    puts("Invalid Base64 string")
end
```quest

### `b64.is_valid_url(encoded)`
Check if string is valid URL-safe Base64

**Parameters:**
- `encoded` - String to validate (Str)

**Returns:** Bool (true if valid URL-safe Base64)

## Common Use Cases

### Encoding Binary Data for Text Transmission
```quest
# Read binary file and encode for transmission
let file_data = io.read_bytes("image.png")
let encoded = b64.encode(file_data)
puts("Encoded image: ", encoded)
```quest

### Decoding API Responses
```quest
# Decode Base64 data from API
let api_response = http.get("https://api.example.com/data")
let decoded = b64.decode(api_response.body)
puts(decoded)
```quest

### URL-Safe Tokens
```quest
# Create URL-safe token
let token_data = "user:123:expires:2024"
let token = b64.encode_url(token_data)
puts("Token: ", token)

# Later, decode the token
let decoded_token = b64.decode_url(token)
puts("User data: ", decoded_token)
```quest

### Validating User Input
```quest
let user_input = io.read_line()

if !b64.is_valid(user_input)
    puts("Error: Invalid Base64 input")
    return
end

let decoded = b64.decode(user_input)
puts("Decoded: ", decoded)
```quest

### Encoding Configuration Data
```quest
# Encode config for storage
let config = json.stringify({"host": "localhost", "port": 8080})
let encoded_config = b64.encode(config)
io.write("config.b64", encoded_config)

# Decode config when loading
let loaded = io.read("config.b64")
let config_str = b64.decode(loaded)
let config_obj = json.parse(config_str)
puts("Host: ", config_obj.host)
```quest
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sys-module"><a class="header" href="#sys-module">sys Module</a></h1>
<p>The <code>sys</code> module provides access to system-level information and runtime details, similar to Python's <code>sys</code> module.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<pre><code class="language-quest"># The sys module is automatically available in scripts
puts("Version:", sys.version)
puts("Platform:", sys.platform)
puts("Args:", sys.argv)
```quest

**Note**: The `sys` module is automatically injected into script scope and doesn't need to be imported.

## Module Properties

### `sys.version`

The Quest version string.

**Type:** Str

**Example:**
```quest
puts("Quest version:", sys.version)
# Output: Quest version: 0.1.0
```quest

### `sys.platform`

The operating system platform name.

**Type:** Str

**Values:**
- `"darwin"` - macOS
- `"linux"` - Linux
- `"win32"` - Windows
- `"freebsd"` - FreeBSD
- `"openbsd"` - OpenBSD
- `"unknown"` - Other/unrecognized platforms

**Example:**
```quest
if sys.platform == "darwin"
    puts("Running on macOS")
elif sys.platform == "linux"
    puts("Running on Linux")
elif sys.platform == "win32"
    puts("Running on Windows")
end
```quest

### `sys.executable`

The absolute path to the Quest executable.

**Type:** Str

**Example:**
```quest
puts("Quest executable:", sys.executable)
# Output: Quest executable: /usr/local/bin/quest
```quest

### `sys.builtin_module_names`

Array of all built-in module names that can be imported.

**Type:** Array of Str

**Example:**
```quest
puts("Available modules:", sys.builtin_module_names)
# Output: Available modules: [math, os, term, hash, json, io, sys]

# Check if a module is available
if sys.builtin_module_names.contains("math")
    use math
    puts("Math module available!")
end
```quest

### `sys.argc`

The number of command-line arguments passed to the script, including the script name.

**Type:** Num

**Example:**
```quest
# script.q
puts("Number of arguments:", sys.argc)
```quest

```bash
$ quest script.q
Number of arguments: 1

$ quest script.q arg1 arg2
Number of arguments: 3
```quest

### `sys.argv`

Array containing all command-line arguments. The first element (`sys.argv[0]`) is always the script name.

**Type:** Array of Str

**Example:**
```quest
# greet.q
if sys.argc &lt; 2
    puts("Usage:", sys.argv[0], "&lt;name&gt;")
else
    puts("Hello,", sys.argv[1] .. "!")
end
```quest

```bash
$ quest greet.q
Usage: greet.q &lt;name&gt;

$ quest greet.q Alice
Hello, Alice!
```quest

## Common Patterns

### Version Checking

```quest
# Check if running a specific version
let required_version = "0.1.0"
if sys.version != required_version
    puts("Warning: This script requires Quest", required_version)
    puts("You are running", sys.version)
end
```quest

### Platform-Specific Behavior

```quest
# Use platform-specific paths
let config_dir = ""
if sys.platform == "win32"
    config_dir = "C:\\Users\\Config"
else
    config_dir = "/home/user/.config"
end
```quest

### Argument Parsing

```quest
#!/usr/bin/env quest
# Simple argument parser

if sys.argc &lt; 2
    puts("Usage:", sys.argv[0], "&lt;command&gt; [options]")
else
    let command = sys.argv[1]

    if command == "help"
        puts("Available commands: help, run, test")
    elif command == "run"
        puts("Running...")
    elif command == "test"
        puts("Testing...")
    else
        puts("Unknown command:", command)
    end
end
```quest

### Processing Multiple Files

```quest
#!/usr/bin/env quest
# process_files.q

if sys.argc &lt; 2
    puts("Usage:", sys.argv[0], "&lt;file1&gt; [file2] [file3] ...")
else
    puts("Processing", sys.argc - 1, "files:")

    # Skip first argument (script name), process rest
    sys.argv.slice(1, sys.argc).each(fun (filename)
        puts("  Processing:", filename)
        # ... process file
    end)
end
```quest

### Flag Parsing

```quest
#!/usr/bin/env quest
# Example with -v verbose flag

let verbose = false
let files = []

# Parse arguments
let i = 1
while i &lt; sys.argc
    let arg = sys.argv[i]

    if arg == "-v" or arg == "--verbose"
        verbose = true
    elif arg.startswith("-")
        puts("Unknown flag:", arg)
    else
        files = files.push(arg)
    end

    i = i + 1
end

if verbose
    puts("Verbose mode enabled")
    puts("Processing", files.len(), "files")
end
```quest

## Practical Examples

### File Processor with Help

```quest
#!/usr/bin/env quest
# file_stats.q - Display file statistics

fun show_help()
    puts("Usage:", sys.argv[0], "&lt;filename&gt;")
    puts("")
    puts("Displays statistics about a file")
    puts("")
    puts("Options:")
    puts("  -h, --help    Show this help message")
end

if sys.argc &lt; 2 or sys.argv[1] == "-h" or sys.argv[1] == "--help"
    show_help()
else
    let filename = sys.argv[1]
    puts("File:", filename)
    puts("Platform:", sys.platform)
    # ... read and process file
end
```quest

### Calculator Script

```quest
#!/usr/bin/env quest
# calc.q - Simple calculator

if sys.argc != 4
    puts("Usage:", sys.argv[0], "&lt;num1&gt; &lt;op&gt; &lt;num2&gt;")
    puts("Example:", sys.argv[0], "5 + 3")
    puts("")
    puts("Operators: +, -, *, /")
else
    # Note: In a real implementation, you'd convert strings to numbers
    let a_str = sys.argv[1]
    let op = sys.argv[2]
    let b_str = sys.argv[3]

    puts("Operation:", a_str, op, b_str)
    # ... perform calculation
end
```quest

### Environment Info

```quest
#!/usr/bin/env quest
# sysinfo.q - Display system information

puts("=== Quest System Information ===")
puts("")
puts("Version:", sys.version)
puts("Platform:", sys.platform)
puts("Executable:", sys.executable)
puts("")
puts("Built-in Modules:")
sys.builtin_module_names.each(fun (name)
    puts("  -", name)
end)
puts("")
puts("Command Line:")
puts("  Script:", sys.argv[0])
puts("  Arguments:", sys.argc - 1)
if sys.argc &gt; 1
    sys.argv.slice(1, sys.argc).each(fun (arg, idx)
        puts("    [" .. idx._str() .. "]:", arg)
    end)
end
```quest

## Differences from Python's sys Module

### Similar Features
- ✅ `sys.argv` - Command line arguments (same concept)
- ✅ `sys.version` - Version string (similar)
- ✅ `sys.platform` - Platform name (similar)
- ✅ `sys.executable` - Executable path (similar)

### Quest-Specific
- ✅ `sys.argc` - Argument count (not in Python, Python uses `len(sys.argv)`)
- ✅ `sys.builtin_module_names` - Quest's built-in modules

### Not Implemented (yet)
- ❌ `sys.exit()` - Exit with status code
- ❌ `sys.stdin`, `sys.stdout`, `sys.stderr` - Standard streams
- ❌ `sys.path` - Module search paths (Quest uses `os.search_path`)
- ❌ `sys.modules` - Loaded modules cache

## Notes

- The `sys` module is **automatically available** in scripts - no `use sys` required
- In the REPL, `sys` is not available since there's no script context
- All `sys` properties are **read-only** - attempting to modify them has no effect
- `sys.argv` always includes the script name as the first element

## Best Practices

1. **Always check argc before accessing argv**
   ```quest
   if sys.argc &gt; 1
       let arg = sys.argv[1]
   end
</code></pre>
<ol start="2">
<li>
<p><strong>Provide usage information</strong></p>
<pre><code class="language-quest">if sys.argc &lt; 2
    puts("Usage:", sys.argv[0], "&lt;required_arg&gt;")
end
</code></pre>
</li>
<li>
<p><strong>Use sys.platform for cross-platform code</strong></p>
<pre><code class="language-quest">let path_sep = if sys.platform == "win32" "\\" else "/" end
</code></pre>
</li>
<li>
<p><strong>Store argv values in named variables</strong></p>
<pre><code class="language-quest">let script_name = sys.argv[0]
let input_file = if sys.argc &gt; 1 sys.argv[1] else "" end
</code></pre>
</li>
</ol>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>The <code>sys</code> module provides essential system and runtime information:</p>
<ul>
<li><strong><code>sys.version</code></strong> - Quest version</li>
<li><strong><code>sys.platform</code></strong> - OS platform name</li>
<li><strong><code>sys.executable</code></strong> - Path to Quest executable</li>
<li><strong><code>sys.builtin_module_names</code></strong> - Available built-in modules</li>
<li><strong><code>sys.argc</code></strong> - Argument count</li>
<li><strong><code>sys.argv</code></strong> - Argument array</li>
</ul>
<p>Use these properties to build flexible, cross-platform Quest scripts!</p>
<div style="break-before: page; page-break-before: always;"></div><p>os.listdir(path): Lists the contents of a directory.
os.mkdir(path): Creates a new directory.
os.rmdir(path): Removes an empty directory.
os.remove(path): Deletes a file.
os.rename(src, dst): Renames a file or directory.
os.environ(): return environment vars as a dict
os.setenv(key, value)
os.getenv(key)
os.getcwd(): Returns the current working directory.
os.chdir(path): Changes the current working directory.</p>
<div style="break-before: page; page-break-before: always;"></div><p>time()
datetime()</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="term-module"><a class="header" href="#term-module">Term Module</a></h1>
<p>The <code>term</code> module provides terminal control functions including colors, text attributes, cursor control, and screen management.</p>
<h2 id="text-color-functions"><a class="header" href="#text-color-functions">Text Color Functions</a></h2>
<h3 id="termcolortext-color-attrs--"><a class="header" href="#termcolortext-color-attrs--"><code>term.color(text, color, attrs = [])</code></a></h3>
<p>Return colored text with optional attributes</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>text</code> - Text to colorize (Str)</li>
<li><code>color</code> - Color name (Str): "red", "green", "yellow", "blue", "magenta", "cyan", "white", "grey"</li>
<li><code>attrs</code> - Optional list of attributes (List): "bold", "dimmed", "underline", "blink", "reverse", "hidden"</li>
</ul>
<p><strong>Returns:</strong> Colored text string (Str)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-quest">puts(term.color("Error!", "red", ["bold"]))
puts(term.color("Success", "green"))
```quest

### `term.on_color(text, color)`
Return text with background color

**Parameters:**
- `text` - Text to colorize (Str)
- `color` - Background color name (Str): "red", "green", "yellow", "blue", "magenta", "cyan", "white", "grey"

**Returns:** Text with background color (Str)

**Example:**
```quest
puts(term.on_color("Warning", "yellow"))
```quest

### Convenience Color Functions

Quick color functions that take text and optional attributes:

- `term.red(text, attrs = [])`
- `term.green(text, attrs = [])`
- `term.yellow(text, attrs = [])`
- `term.blue(text, attrs = [])`
- `term.magenta(text, attrs = [])`
- `term.cyan(text, attrs = [])`
- `term.white(text, attrs = [])`
- `term.grey(text, attrs = [])`

**Example:**
```quest
puts(term.red("Error: File not found"))
puts(term.green("Test passed", ["bold"]))
puts(term.yellow("Warning: deprecated function"))
```quest

## Text Attribute Functions

### `term.bold(text)`
Return bold text

### `term.dimmed(text)`
Return dimmed text

### `term.underline(text)`
Return underlined text

### `term.blink(text)`
Return blinking text (may not work in all terminals)

### `term.reverse(text)`
Return text with reversed foreground/background

### `term.hidden(text)`
Return hidden text

**Example:**
```quest
puts(term.bold("Important Message"))
puts(term.underline("Underlined text"))
```quest

## Cursor Control

### `term.move_up(n = 1)`
Move cursor up n lines

**Parameters:**
- `n` - Number of lines (Num, default 1)

### `term.move_down(n = 1)`
Move cursor down n lines

### `term.move_left(n = 1)`
Move cursor left n columns

### `term.move_right(n = 1)`
Move cursor right n columns

### `term.move_to(row, col)`
Move cursor to specific position

**Parameters:**
- `row` - Row number (Num, 1-indexed)
- `col` - Column number (Num, 1-indexed)

**Example:**
```quest
term.move_to(1, 1)  # Move to top-left corner
puts("Header")
```quest

### `term.save_cursor()`
Save current cursor position

### `term.restore_cursor()`
Restore previously saved cursor position

## Screen Control

### `term.clear()`
Clear entire screen

### `term.clear_line()`
Clear current line

### `term.clear_to_end()`
Clear from cursor to end of screen

### `term.clear_to_start()`
Clear from cursor to start of screen

**Example:**
```quest
term.clear()
term.move_to(1, 1)
puts("Fresh screen!")
```quest

## Terminal Properties

### `term.width()`
Get terminal width in columns

**Returns:** Number of columns (Num)

### `term.height()`
Get terminal height in rows

**Returns:** Number of rows (Num)

### `term.size()`
Get terminal size as [height, width]

**Returns:** List containing [rows, columns]

**Example:**
```quest
let size = term.size()
puts("Terminal is ", size[1], "x", size[0])
```quest

## Style Combinations

### `term.styled(text, fg = nil, bg = nil, attrs = [])`
Apply multiple styles at once

**Parameters:**
- `text` - Text to style (Str)
- `fg` - Foreground color name or nil (Str or Nil)
- `bg` - Background color name or nil (Str or Nil)
- `attrs` - List of attributes (List)

**Returns:** Styled text (Str)

**Example:**
```quest
puts(term.styled("ERROR", "white", "red", ["bold"]))
puts(term.styled("Success", "green", nil, ["bold", "underline"]))
```quest

## ANSI Control

### `term.reset()`
Return ANSI reset code to clear all formatting

**Returns:** Reset string (Str)

### `term.strip_colors(text)`
Remove all ANSI color codes from text

**Parameters:**
- `text` - Text with ANSI codes (Str)

**Returns:** Plain text without codes (Str)

**Example:**
```quest
let colored = term.red("Error")
let plain = term.strip_colors(colored)
```quest

## Progress Indicators

### `term.progress_bar(current, total, width = 50, char = "=")`
Create a text-based progress bar

**Parameters:**
- `current` - Current progress value (Num)
- `total` - Total/maximum value (Num)
- `width` - Width of bar in characters (Num, default 50)
- `char` - Character to use for filled portion (Str, default "=")

**Returns:** Progress bar string (Str)

**Example:**
```quest
let progress = term.progress_bar(75, 100, 40)
puts(progress, " 75%")
# Output: [==============================          ] 75%
```quest

### `term.spinner(frame)`
Get spinner animation frame

**Parameters:**
- `frame` - Frame number (Num)

**Returns:** Spinner character (Str)

**Example:**
```quest
let frames = ["", "", "9", "8", "&lt;", "4", "&amp;", "'", "", ""]
let i = 0
loop
    print("\r", term.spinner(i), " Loading...")
    sleep(0.1)
    i = (i + 1) % 10
end
```quest

## Common Use Cases

### Logging Levels
```quest
# Different colored log levels
puts("[", term.blue("INFO"), "] Server started")
puts("[", term.yellow("WARN"), "] High memory usage")
puts("[", term.red("ERROR", ["bold"]), "] Connection failed")
puts("[", term.green("OK"), "] All tests passed")
```quest

### Highlighting
```quest
# Highlight specific parts of output
puts("Found ", term.cyan(file_count), " files in ", term.yellow(directory))
```quest

### Status Messages
```quest
# Success/failure messages
if result
    puts(term.green(""), " Operation completed successfully")
else
    puts(term.red(""), " Operation failed")
end
```quest

### Tables and Borders
```quest
# Create formatted tables
term.clear()
puts(term.bold(term.blue("=" * 60)))
puts(term.bold("Report Summary"))
puts(term.bold(term.blue("=" * 60)))
puts("Total: ", term.cyan(total))
puts("Passed: ", term.green(passed))
puts("Failed: ", term.red(failed))
```quest
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="test-module"><a class="header" href="#test-module">Test Module</a></h1>
<p>The <code>test</code> module provides a testing framework for Quest with assertions, test organization, and reporting.</p>
<h2 id="test-definition"><a class="header" href="#test-definition">Test Definition</a></h2>
<h3 id="testdescribename-fn"><a class="header" href="#testdescribename-fn"><code>test.describe(name, fn)</code></a></h3>
<p>Define a test suite/group</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>name</code> - Suite name (Str)</li>
<li><code>fn</code> - Function containing tests</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-quest">test.describe("String operations", fun ()
    test.it("concatenates strings", fun ()
        test.assert_eq("hello" + " world", "hello world")
    end)

    test.it("converts to uppercase", fun ()
        test.assert_eq("hello".upper(), "HELLO")
    end)
end)
```quest

### `test.it(name, fn)`
Define a single test case

**Parameters:**
- `name` - Test name/description (Str)
- `fn` - Test function to execute

**Example:**
```quest
test.it("adds numbers correctly", fun ()
    test.assert_eq(2 + 2, 4)
end)
```quest

### `test.before(fn)`
Run setup function before each test in current suite

**Parameters:**
- `fn` - Setup function

**Example:**
```quest
test.describe("Database tests", fun ()
    test.before(fun ()
        db.connect()
        db.clear()
    end)

    test.it("inserts records", fun ()
        db.insert("users", {"name": "Alice"})
        test.assert_eq(db.count("users"), 1)
    end)
end)
```quest

### `test.after(fn)`
Run teardown function after each test in current suite

**Parameters:**
- `fn` - Teardown function

**Example:**
```quest
test.describe("File tests", fun ()
    test.after(fun ()
        io.remove("test_output.txt")
    end)

    test.it("writes to file", fun ()
        io.write("test_output.txt", "data")
        test.assert(io.exists("test_output.txt"))
    end)
end)
```quest

### `test.before_all(fn)`
Run setup once before all tests in suite

**Parameters:**
- `fn` - Setup function

### `test.after_all(fn)`
Run teardown once after all tests in suite

**Parameters:**
- `fn` - Teardown function

## Assertions

### `test.assert(condition, message = nil)`
Assert that condition is true

**Parameters:**
- `condition` - Boolean condition (Bool)
- `message` - Optional failure message (Str)

**Raises:** AssertionError if condition is false

**Example:**
```quest
test.assert(5 &gt; 3)
test.assert(user.is_admin(), "User must be admin")
```quest

### `test.assert_eq(actual, expected, message = nil)`
Assert that two values are equal

**Parameters:**
- `actual` - Actual value
- `expected` - Expected value
- `message` - Optional failure message (Str)

**Example:**
```quest
test.assert_eq(2 + 2, 4)
test.assert_eq("hello".len(), 5, "Wrong string length")
```quest

### `test.assert_neq(actual, expected, message = nil)`
Assert that two values are not equal

**Parameters:**
- `actual` - Actual value
- `expected` - Value that should not match
- `message` - Optional failure message (Str)

**Example:**
```quest
test.assert_neq(result, nil)
test.assert_neq(user_id, previous_id)
```quest

### `test.assert_gt(actual, expected, message = nil)`
Assert that actual is greater than expected

**Parameters:**
- `actual` - Actual value (Num)
- `expected` - Expected threshold (Num)
- `message` - Optional failure message (Str)

**Example:**
```quest
test.assert_gt(score, 100)
```quest

### `test.assert_lt(actual, expected, message = nil)`
Assert that actual is less than expected

**Parameters:**
- `actual` - Actual value (Num)
- `expected` - Expected threshold (Num)
- `message` - Optional failure message (Str)

### `test.assert_gte(actual, expected, message = nil)`
Assert that actual is greater than or equal to expected

### `test.assert_lte(actual, expected, message = nil)`
Assert that actual is less than or equal to expected

### `test.assert_nil(value, message = nil)`
Assert that value is nil

**Parameters:**
- `value` - Value to check
- `message` - Optional failure message (Str)

**Example:**
```quest
test.assert_nil(optional_param)
```quest

### `test.assert_not_nil(value, message = nil)`
Assert that value is not nil

**Example:**
```quest
test.assert_not_nil(result, "Result should not be nil")
```quest

### `test.assert_type(value, type_name, message = nil)`
Assert that value is of specific type

**Parameters:**
- `value` - Value to check
- `type_name` - Expected type name (Str): "Num", "Str", "Bool", "List", etc.
- `message` - Optional failure message (Str)

**Example:**
```quest
test.assert_type(result, "Num")
test.assert_type(names, "List")
```quest

### `test.assert_contains(collection, item, message = nil)`
Assert that collection contains item

**Parameters:**
- `collection` - List or string to search
- `item` - Item to find
- `message` - Optional failure message (Str)

**Example:**
```quest
test.assert_contains([1, 2, 3], 2)
test.assert_contains("hello world", "world")
```quest

### `test.assert_not_contains(collection, item, message = nil)`
Assert that collection does not contain item

**Example:**
```quest
test.assert_not_contains(banned_users, user_id)
```quest

### `test.assert_len(collection, expected_len, message = nil)`
Assert that collection has expected length

**Parameters:**
- `collection` - List or string
- `expected_len` - Expected length (Num)
- `message` - Optional failure message (Str)

**Example:**
```quest
test.assert_len(results, 10)
test.assert_len("hello", 5)
```quest

### `test.assert_empty(collection, message = nil)`
Assert that collection is empty

**Example:**
```quest
test.assert_empty([])
test.assert_empty("")
```quest

### `test.assert_not_empty(collection, message = nil)`
Assert that collection is not empty

### `test.assert_raises(fn, error_type = nil, message = nil)`
Assert that function raises an error

**Parameters:**
- `fn` - Function to execute
- `error_type` - Optional expected error type (Str)
- `message` - Optional failure message (Str)

**Example:**
```quest
test.assert_raises(fun ()
    1 / 0
end)

test.assert_raises(fun ()
    io.read("nonexistent.txt")
end, "FileNotFoundError")
```quest

### `test.assert_matches(text, pattern, message = nil)`
Assert that text matches regex pattern

**Parameters:**
- `text` - Text to match (Str)
- `pattern` - Regex pattern (Str)
- `message` - Optional failure message (Str)

**Example:**
```quest
test.assert_matches(email, "^[a-z]+@[a-z]+\\.[a-z]+$")
```quest

### `test.assert_near(actual, expected, tolerance = 0.0001, message = nil)`
Assert that numbers are approximately equal (for floating point)

**Parameters:**
- `actual` - Actual value (Num)
- `expected` - Expected value (Num)
- `tolerance` - Acceptable difference (Num, default 0.0001)
- `message` - Optional failure message (Str)

**Example:**
```quest
test.assert_near(math.pi, 3.14159, 0.00001)
test.assert_near(result, 2.5, 0.1)
```quest

## Test Control

### `test.skip(reason = nil)`
Skip current test

**Parameters:**
- `reason` - Optional reason for skipping (Str)

**Example:**
```quest
test.it("integration test", fun ()
    if !has_network()
        test.skip("No network connection")
    end

    # test code...
end)
```quest

### `test.skip_if(condition, reason = nil)`
Skip test if condition is true

**Parameters:**
- `condition` - Boolean condition (Bool)
- `reason` - Optional reason (Str)

**Example:**
```quest
test.it("runs on Unix only", fun ()
    test.skip_if(sys.platform() == "windows", "Unix only")
    # test code...
end)
```quest

### `test.fail(message)`
Explicitly fail the test

**Parameters:**
- `message` - Failure message (Str)

**Example:**
```quest
test.it("validates behavior", fun ()
    if weird_edge_case()
        test.fail("Unexpected edge case encountered")
    end
end)
```quest

## Test Running

### `test.run()`
Run all defined tests and print results

**Returns:** Exit code (Num): 0 if all pass, 1 if any fail

**Example:**
```quest
# At end of test file
test.run()
```quest

### `test.run_file(path)`
Load and run tests from file

**Parameters:**
- `path` - Path to test file (Str)

**Returns:** Exit code (Num)

**Example:**
```quest
test.run_file("tests/string_test.q")
```quest

### `test.run_dir(path)`
Run all test files in directory

**Parameters:**
- `path` - Directory path (Str)

**Returns:** Exit code (Num)

**Example:**
```quest
# Run all tests in tests/ directory
test.run_dir("tests")
```quest

## Test Output

### `test.set_reporter(reporter)`
Set output reporter style

**Parameters:**
- `reporter` - Reporter name (Str): "default", "verbose", "minimal", "json", "tap"

**Example:**
```quest
test.set_reporter("verbose")
test.run()
```quest

### `test.set_color(enabled)`
Enable or disable colored output

**Parameters:**
- `enabled` - Whether to use colors (Bool)

## Mocking and Stubbing

### `test.stub(obj, method, replacement)`
Replace method with stub for testing

**Parameters:**
- `obj` - Object to stub
- `method` - Method name (Str)
- `replacement` - Replacement function

**Returns:** Stub handle for cleanup

**Example:**
```quest
test.it("mocks API call", fun ()
    let stub = test.stub(api, "fetch", fun (url)
        return {"status": 200, "data": "mock"}
    end)

    let result = api.fetch("http://example.com")
    test.assert_eq(result.status, 200)

    stub.restore()
end)
```quest

### `test.spy(fn)`
Create spy that tracks function calls

**Parameters:**
- `fn` - Function to spy on

**Returns:** Spy object with call tracking

**Example:**
```quest
let spy = test.spy(callback)
do_something(spy)

test.assert(spy.called())
test.assert_eq(spy.call_count(), 2)
test.assert_eq(spy.calls[0].args, [1, 2, 3])
```quest

## Test Fixtures

### `test.fixture(name, fn)`
Define reusable test fixture

**Parameters:**
- `name` - Fixture name (Str)
- `fn` - Function that returns fixture data

**Example:**
```quest
test.fixture("sample_users", fun ()
    return [
        {"name": "Alice", "age": 30},
        {"name": "Bob", "age": 25}
    ]
end)

test.it("processes users", fun ()
    let users = test.use_fixture("sample_users")
    test.assert_len(users, 2)
end)
```quest

## Benchmarking

### `test.benchmark(name, fn, iterations = 1000)`
Benchmark function execution time

**Parameters:**
- `name` - Benchmark name (Str)
- `fn` - Function to benchmark
- `iterations` - Number of iterations (Num, default 1000)

**Example:**
```quest
test.benchmark("string concatenation", fun ()
    let s = ""
    for i in 1..100
        s = s + "x"
    end
end, 1000)
```quest

## Complete Example

```quest
# tests/calculator_test.q

test.describe("Calculator", fun ()
    test.describe("addition", fun ()
        test.it("adds positive numbers", fun ()
            test.assert_eq(calc.add(2, 3), 5)
        end)

        test.it("adds negative numbers", fun ()
            test.assert_eq(calc.add(-2, -3), -5)
        end)

        test.it("handles zero", fun ()
            test.assert_eq(calc.add(0, 5), 5)
            test.assert_eq(calc.add(5, 0), 5)
        end)
    end)

    test.describe("division", fun ()
        test.it("divides numbers", fun ()
            test.assert_eq(calc.div(10, 2), 5)
        end)

        test.it("handles decimal results", fun ()
            test.assert_near(calc.div(7, 3), 2.333, 0.01)
        end)

        test.it("raises error on division by zero", fun ()
            test.assert_raises(fun ()
                calc.div(5, 0)
            end, "DivisionByZeroError")
        end)
    end)
end)

# Run all tests
test.run()
```quest

## Command Line Usage

```bash
# Run single test file
quest tests/calculator_test.q

# Run all tests in directory
quest -test tests/

# Run with verbose output
quest -test -verbose tests/

# Run specific test
quest -test -only "Calculator addition" tests/calculator_test.q
```quest
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-variables"><a class="header" href="#system-variables">System Variables</a></h1>
<blockquote>
<p><strong>Note:</strong> Quest has moved system information to the <code>sys</code> module instead of global variables. See <a href="advanced/std/sys.html">docs/std/sys.md</a> for full documentation.</p>
</blockquote>
<h2 id="the-sys-module"><a class="header" href="#the-sys-module">The <code>sys</code> Module</a></h2>
<p>Quest provides system information through the <code>sys</code> module, which is automatically available in all scripts without needing to import it.</p>
<h3 id="quick-reference"><a class="header" href="#quick-reference">Quick Reference</a></h3>
<ul>
<li><strong><code>sys.argc</code></strong> - Number of command line arguments</li>
<li><strong><code>sys.argv</code></strong> - Array of command line argument strings</li>
<li><strong><code>sys.version</code></strong> - Quest version string</li>
<li><strong><code>sys.platform</code></strong> - Operating system name (darwin, linux, win32, etc.)</li>
<li><strong><code>sys.executable</code></strong> - Path to Quest executable</li>
<li><strong><code>sys.builtin_module_names</code></strong> - Array of available built-in modules</li>
</ul>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre><code class="language-quest"># script.q
puts("Version:", sys.version)
puts("Platform:", sys.platform)
puts("Number of arguments:", sys.argc)
puts("Arguments:", sys.argv)
```quest

```bash
$ quest script.q arg1 arg2
Version: 0.1.0
Platform: darwin
Number of arguments: 3
Arguments: [script.q, arg1, arg2]
```quest

## Command Line Arguments

### `sys.argc`

The number of command line arguments passed to the script, including the script name.

**Type:** Num

**Example:**
```quest
# script.q
puts("Number of arguments:", sys.argc)
```quest

```bash
$ quest script.q
Number of arguments: 1

$ quest script.q arg1 arg2
Number of arguments: 3
```quest

### `sys.argv`

An array containing all command line arguments. The first element (`sys.argv[0]`) is always the script name.

**Type:** Array of Str

**Example:**
```quest
# greet.q
if sys.argc &lt; 2
    puts("Usage:", sys.argv[0], "&lt;name&gt;")
else
    puts("Hello,", sys.argv[1] .. "!")
end
```quest

```bash
$ quest greet.q
Usage: greet.q &lt;name&gt;

$ quest greet.q Alice
Hello, Alice!
```quest

## Working with Arguments

### Accessing Arguments

Access individual arguments by index:

```quest
let script_name = sys.argv[0]
let first_arg = sys.argv[1]
let second_arg = sys.argv[2]
```quest

### Checking Argument Count

Always check `sys.argc` before accessing arguments:

```quest
if sys.argc &lt; 2
    puts("Error: Missing required argument")
else
    let input_file = sys.argv[1]
    # ... process file
end
```quest

### Processing All Arguments

Process all arguments except the script name:

```quest
# print_args.q
puts("Script: ", sys.argv[0])
puts("Arguments:")

let i = 1
if sys.argc &gt; 1
    puts("  ", sys.argv[1])
end
if sys.argc &gt; 2
    puts("  ", sys.argv[2])
end
if sys.argc &gt; 3
    puts("  ", sys.argv[3])
end
# ... continue for expected number of args
```quest

**Note:** Quest doesn't have traditional for loops yet, so you need to check each argument explicitly.

### Parsing Flags and Options

Example of a script that handles flags:

```quest
# process.q
let verbose = false
let input_file = ""
let i = 1

# Check for -v flag
if sys.argc &gt; 1 and sys.argv[1] == "-v"
    verbose = true
    i = 2
end

# Get input file
if sys.argc &gt; i
    input_file = sys.argv[i]
else
    puts("Usage: ", sys.argv[0], " [-v] &lt;input_file&gt;")
end

if verbose
    puts("Processing: ", input_file)
end
```quest

```bash
$ quest process.q data.txt
$ quest process.q -v data.txt
Processing: data.txt
```quest

## Practical Examples

### File Processor

```quest
#!/usr/bin/env quest
# file_stats.q - Display file statistics

if sys.argc != 2
    puts("Usage: ", sys.argv[0], " &lt;filename&gt;")
else
    let filename = sys.argv[1]
    puts("File: ", filename)
    # Read and process file...
end
```quest

### Calculator

```quest
#!/usr/bin/env quest
# calc.q - Simple calculator

if sys.argc != 4
    puts("Usage: ", sys.argv[0], " &lt;num1&gt; &lt;op&gt; &lt;num2&gt;")
    puts("Example: ", sys.argv[0], " 5 + 3")
else
    let a = sys.argv[1]
    let op = sys.argv[2]
    let b = sys.argv[3]

    # Note: Convert strings to numbers first
    # (Quest will need string-to-number conversion)
    puts(a, " ", op, " ", b, " = result")
end
```quest

### Multi-File Processor

```quest
#!/usr/bin/env quest
# process_files.q

if sys.argc &lt; 2
    puts("Usage: ", sys.argv[0], " &lt;file1&gt; [file2] [file3] ...")
else
    puts("Processing ", sys.argc - 1, " files:")

    if sys.argc &gt; 1
        puts("  ", sys.argv[1])
    end
    if sys.argc &gt; 2
        puts("  ", sys.argv[2])
    end
    if sys.argc &gt; 3
        puts("  ", sys.argv[3])
    end
end
```quest

## Differences from Other Languages

### Bash

```bash
# Bash
echo "Script: $0"
echo "First arg: $1"
echo "All args: $@"
echo "Arg count: $#"
```quest

```quest
# Quest
puts("Script: ", sys.argv[0])
puts("First arg: ", sys.argv[1])
puts("All args: ", sys.argv)
puts("Arg count: ", sys.argc)
```quest

### Python

```python
# Python
import sys
print(f"Script: {sys.argv[0]}")
print(f"Args: {sys.argv[1:]}")
print(f"Count: {len(sys.argv)}")
```quest

```quest
# Quest
puts("Script: ", sys.argv[0])
# No direct way to slice arrays yet
puts("Count: ", sys.argc)
```quest

### Node.js

```javascript
// Node.js
console.log("Script:", process.argv[1]);
console.log("Args:", process.argv.slice(2));
console.log("Count:", process.argv.length);
```quest

```quest
# Quest
puts("Script: ", sys.argv[0])
puts("Args: ", sys.argv)
puts("Count: ", sys.argc)
```quest

## Behavior in Different Contexts

### Script Files

When running a script file:
- `sys.argv[0]` is the script filename
- Additional arguments follow in `sys.argv[1]`, `sys.argv[2]`, etc.

```bash
$ quest script.q arg1 arg2
# sys.argc = 3
# sys.argv = ["script.q", "arg1", "arg2"]
```quest

### Piped Input

When piping code to Quest:
- `sys.argv[0]` is the Quest executable path
- No additional arguments available

```bash
$ echo 'puts(sys.argv[0])' | quest
# sys.argc = 1
# sys.argv = ["./quest"]
```quest

### Interactive REPL

In the REPL, `sys.argc` and `sys.argv` are not available since there's no script context.

## Best Practices

### 1. Always Validate Arguments

```quest
if sys.argc &lt; 2
    puts("Error: Missing required argument")
    puts("Usage: ", sys.argv[0], " &lt;filename&gt;")
    # Exit would be useful here
end
```quest

### 2. Provide Usage Information

```quest
fun show_usage()
    puts("Usage: ", sys.argv[0], " [options] &lt;input&gt;")
    puts("Options:")
    puts("  -v, --verbose    Enable verbose output")
    puts("  -h, --help       Show this help")
end

if sys.argc &lt; 2
    show_usage()
end
```quest

### 3. Handle Edge Cases

```quest
# Check for empty arguments
if sys.argc &gt; 1 and sys.argv[1] == ""
    puts("Error: Empty argument provided")
end
```quest

### 4. Store Arguments in Named Variables

```quest
let program_name = sys.argv[0]
let input_file = ""
let output_file = ""

if sys.argc &gt; 1
    input_file = sys.argv[1]
end

if sys.argc &gt; 2
    output_file = sys.argv[2]
end
```quest

## Limitations

- **No argument slicing:** Cannot easily get `sys.argv[1:]` (all args except script name)
- **No iteration:** Must check each argument index explicitly
- **No type conversion:** Arguments are always strings, need manual conversion
- **No REPL access:** `sys.argc` and `sys.argv` only available in scripts

## Future Enhancements

Quest may add:
- Array slicing: `sys.argv[1:]` to skip script name
- For loops: Iterate over all arguments
- Argument parsing library: Built-in flag/option parsing
- Type conversion: `str.to_num()`, `str.to_bool()`
- Exit codes: Ability to exit with specific status

## Summary

- **`sys.argc`** - Number of command line arguments (including script name)
- **`sys.argv`** - Array of command line argument strings
- **`sys.argv[0]`** - Always the script filename
- Available automatically in all scripts
- Arguments are always strings
- Check `sys.argc` before accessing `sys.argv` elements

Use these variables to build flexible command-line tools in Quest!
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/quest-highlight.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
