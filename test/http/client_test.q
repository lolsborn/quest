use "std/test" { module, describe, it, assert_eq, assert_nil, assert_type, assert, tag }
use "std/http/client" as http

module("HTTP Client")

tag("slow")
describe("Basic GET requests", fun ()
  it("performs simple GET request", fun ()
    let resp = http.get("http://localhost:6123/get")
    assert(resp.ok(), "Response should be OK")
    assert_eq(resp.status(), 200)
  end)

  it("returns valid response object", fun ()
    let resp = http.get("http://localhost:6123/get")
    assert_type(resp, "HttpResponse", "Should return HttpResponse")
  end)

  it("tracks final URL", fun ()
    let resp = http.get("http://localhost:6123/get")
    let url = resp.url()
    assert(url.contains("localhost:6123"), "URL should contain localhost:6123")
  end)
end)

tag("slow")
describe("Response body parsing", fun ()
  it("parses JSON response", fun ()
    let resp = http.get("http://localhost:6123/json")
    let json = resp.json()
    assert_type(json, "Dict", "Should return Dict for JSON")
  end)

  it("returns text response", fun ()
    let resp = http.get("http://localhost:6123/robots.txt")
    let text = resp.text()
    assert_type(text, "Str", "Should return Str for text")
    assert(text.len() > 0, "Text should not be empty")
  end)

  it("returns bytes response", fun ()
    let resp = http.get("http://localhost:6123/bytes/50")
    let bts = resp.bytes()
    assert_type(bts, "Bytes", "Should return Bytes")
    assert_eq(bts.len(), 50, "Should return exactly 50 bytes")
  end)

  it("caches body after first access", fun ()
    let resp = http.get("http://localhost:6123/get")
    let text1 = resp.text()
    let text2 = resp.text()
    assert_eq(text1, text2, "Should return same cached text")
  end)
end)

tag("slow")
describe("Response headers", fun ()
  it("accesses headers case-insensitively", fun ()
    let resp = http.get("http://localhost:6123/get")
    let ct1 = resp.header("content-type")
    let ct2 = resp.header("Content-Type")
    let ct3 = resp.header("CONTENT-TYPE")
    assert_eq(ct1, ct2, "Should be case-insensitive")
    assert_eq(ct2, ct3, "Should be case-insensitive")
  end)

  it("returns nil for missing headers", fun ()
    let resp = http.get("http://localhost:6123/get")
    let missing = resp.header("X-Non-Existent-Header")
    assert_nil(missing, "Missing header should return nil")
  end)

  it("checks header existence", fun ()
    let resp = http.get("http://localhost:6123/get")
    assert(resp.has_header("content-type"), "Should have content-type")
    assert(not resp.has_header("x-missing"), "Should not have x-missing")
  end)

  it("returns all headers as dict", fun ()
    let resp = http.get("http://localhost:6123/get")
    let headers = resp.headers()
    assert_type(headers, "Dict", "Should return Dict")
    assert(headers.keys().len() > 0, "Should have headers")
  end)

  it("provides content-type helper", fun ()
    let resp = http.get("http://localhost:6123/json")
    let ct = resp.content_type()
    assert(ct.contains("application/json"), "Should be JSON content type")
  end)
end)

tag("slow")
describe("Status code helpers", fun ()
  it("identifies successful responses", fun ()
    let resp = http.get("http://localhost:6123/status/200")
    assert(resp.ok(), "200 should be ok")
    assert(resp.is_success(), "200 should be success")
  end)

  it("identifies client errors", fun ()
    let resp = http.get("http://localhost:6123/status/404")
    assert(not resp.ok(), "404 should not be ok")
    assert(resp.is_client_error(), "404 should be client error")
    assert_eq(resp.status(), 404)
  end)

  it("identifies server errors", fun ()
    let resp = http.get("http://localhost:6123/status/500")
    assert(resp.is_server_error(), "500 should be server error")
    assert_eq(resp.status(), 500)
  end)

  it("follows redirects automatically", fun ()
    # Note: reqwest follows redirects by default
    # So /status/302 will actually return 200 after following the redirect
    let resp = http.get("http://localhost:6123/status/302")
    # After following redirect, we get a success response
    assert(resp.ok(), "Should successfully follow redirect")
  end)
end)

tag("slow")
describe("Content type detection", fun ()
  it("detects JSON content", fun ()
    let resp = http.get("http://localhost:6123/json")
    assert(resp.is_json(), "Should detect JSON content")
  end)

  it("detects HTML content", fun ()
    let resp = http.get("http://localhost:6123/html")
    assert(resp.is_html(), "Should detect HTML content")
  end)

  it("detects text content", fun ()
    let resp = http.get("http://localhost:6123/robots.txt")
    assert(resp.is_text(), "Should detect text content")
  end)
end)

tag("slow")
describe("HTTP methods", fun ()
  it("performs DELETE request", fun ()
    let resp = http.delete("http://localhost:6123/delete")
    assert_eq(resp.status(), 200)
  end)

  it("performs HEAD request", fun ()
    let resp = http.head("http://localhost:6123/get")
    assert(resp.ok(), "HEAD should succeed")
    assert(resp.has_header("content-type"), "HEAD should return headers")
  end)

  it("performs OPTIONS request", fun ()
    let resp = http.options("http://localhost:6123/get")
    assert(resp.ok(), "OPTIONS should succeed")
  end)
end)

tag("slow")
describe("Client creation and reuse", fun ()
  it("creates new client", fun ()
    let client = http.client()
    assert_type(client, "HttpClient", "Should return HttpClient")
  end)

  it("reuses client for multiple requests", fun ()
    let client = http.client()
    let resp1 = client.get("http://localhost:6123/uuid")
    let resp2 = client.get("http://localhost:6123/uuid")

    assert(resp1.ok(), "First request should succeed")
    assert(resp2.ok(), "Second request should succeed")

    let uuid1 = resp1.json()
    let uuid2 = resp2.json()
    assert(uuid1["uuid"] != uuid2["uuid"], "Should get different UUIDs")
  end)

  it("client has timeout method", fun ()
    let client = http.client()
    let timeout = client.timeout()
    assert_type(timeout, "Int", "Timeout should be an integer")
    assert(timeout > 0, "Timeout should be positive")
  end)
end)

tag("slow")
describe("Response object properties", fun ()
  it("has valid object ID", fun ()
    let resp = http.get("http://localhost:6123/get")
    let id = resp._id()
    assert_type(id, "Int", "ID should be an integer")
    assert(id > 0, "ID should be positive")
  end)

  it("has string representation", fun ()
    let resp = http.get("http://localhost:6123/get")
    let str_repr = resp.str()
    assert_type(str_repr, "Str", "Should return string")
    assert(str_repr.contains("HttpResponse"), "Should mention HttpResponse")
  end)
end)

tag("slow")
describe("Edge cases", fun ()
  it("handles empty response body", fun ()
    let resp = http.get("http://localhost:6123/status/204")
    assert_eq(resp.status(), 204, "Should return 204 No Content")
  end)

  it("handles large response bodies", fun ()
    let resp = http.get("http://localhost:6123/bytes/10000")
    let bts = resp.bytes()
    assert_eq(bts.len(), 10000, "Should handle large responses")
  end)
end)

tag("slow")
describe("Module-level convenience functions", fun ()
  it("http.get() creates temporary client", fun ()
    let resp = http.get("http://localhost:6123/get")
    assert(resp.ok(), "Convenience function should work")
  end)

  it("http.delete() creates temporary client", fun ()
    let resp = http.delete("http://localhost:6123/delete")
    assert(resp.ok(), "Convenience delete should work")
  end)

  it("http.head() creates temporary client", fun ()
    let resp = http.head("http://localhost:6123/get")
    assert(resp.ok(), "Convenience head should work")
  end)
end)
