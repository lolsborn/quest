use "std/test"
use "std/regex"

test.module("Regex Functions")

test.describe("regex.match", fun ()
    test.it("matches simple patterns", fun ()
        test.assert_eq(regex.match("hello", "hello world"), true, nil)
        test.assert_eq(regex.match("hello", "goodbye"), false, nil)
    end)

    test.it("matches regex patterns", fun ()
        test.assert_eq(regex.match("\\d+", "abc123"), true, nil)
        test.assert_eq(regex.match("^\\d+$", "123"), true, nil)
        test.assert_eq(regex.match("^\\d+$", "abc123"), false, nil)
    end)

    test.it("matches case sensitive by default", fun ()
        test.assert_eq(regex.match("hello", "Hello"), false, nil)
    end)
end)

test.describe("regex.find", fun ()
    test.it("finds first match", fun ()
        test.assert_eq(regex.find("\\d+", "abc123def456"), "123", nil)
    end)

    test.it("returns nil when no match", fun ()
        test.assert_nil(regex.find("\\d+", "abcdef"), nil)
    end)

    test.it("finds word patterns", fun ()
        test.assert_eq(regex.find("\\w+", "hello world"), "hello", nil)
    end)
end)

test.describe("regex.find_all", fun ()
    test.it("finds all matches", fun ()
        let matches = regex.find_all("\\d+", "abc123def456ghi789")
        test.assert_eq(matches.len(), 3, nil)
        test.assert_eq(matches.get(0), "123", nil)
        test.assert_eq(matches.get(1), "456", nil)
        test.assert_eq(matches.get(2), "789", nil)
    end)

    test.it("returns empty array when no matches", fun ()
        let matches = regex.find_all("\\d+", "abcdef")
        test.assert_eq(matches.len(), 0, nil)
    end)

    test.it("finds all word patterns", fun ()
        let words = regex.find_all("\\w+", "hello brave new world")
        test.assert_eq(words.len(), 4, nil)
    end)
end)

test.describe("regex.captures", fun ()
    test.it("captures groups", fun ()
        let caps = regex.captures("(\\w+)@(\\w+\\.\\w+)", "user@example.com")
        test.assert_eq(caps.len(), 3, nil)
        test.assert_eq(caps.get(0), "user@example.com", nil) # Full match
        test.assert_eq(caps.get(1), "user", nil)
        test.assert_eq(caps.get(2), "example.com", nil)
    end)

    test.it("returns nil when no match", fun ()
        test.assert_nil(regex.captures("\\d+", "abc"), nil)
    end)

    test.it("captures date components", fun ()
        let caps = regex.captures("(\\d{4})-(\\d{2})-(\\d{2})", "2024-10-02")
        test.assert_eq(caps.get(1), "2024", nil)
        test.assert_eq(caps.get(2), "10", nil)
        test.assert_eq(caps.get(3), "02", nil)
    end)
end)

test.describe("regex.captures_all", fun ()
    test.it("captures all matches with groups", fun ()
        let all = regex.captures_all("(\\d+)-(\\d+)", "10-20 and 30-40")
        test.assert_eq(all.len(), 2, nil)

        let first = all.get(0)
        test.assert_eq(first.get(0), "10-20", nil)
        test.assert_eq(first.get(1), "10", nil)
        test.assert_eq(first.get(2), "20", nil)

        let second = all.get(1)
        test.assert_eq(second.get(0), "30-40", nil)
        test.assert_eq(second.get(1), "30", nil)
        test.assert_eq(second.get(2), "40", nil)
    end)

    test.it("returns empty array when no matches", fun ()
        let all = regex.captures_all("\\d+", "abc")
        test.assert_eq(all.len(), 0, nil)
    end)
end)

test.describe("regex.replace", fun ()
    test.it("replaces first match", fun ()
        let result = regex.replace("\\d+", "abc123def456", "NUM")
        test.assert_eq(result, "abcNUMdef456", nil)
    end)

    test.it("returns original when no match", fun ()
        let result = regex.replace("\\d+", "abcdef", "NUM")
        test.assert_eq(result, "abcdef", nil)
    end)

    test.it("replaces with captured groups", fun ()
        let result = regex.replace("(\\w+)@(\\w+)", "user@example", "$2@$1")
        test.assert_eq(result, "example@user", nil)
    end)
end)

test.describe("regex.replace_all", fun ()
    test.it("replaces all matches", fun ()
        let result = regex.replace_all("\\d+", "abc123def456", "NUM")
        test.assert_eq(result, "abcNUMdefNUM", nil)
    end)

    test.it("replaces multiple occurrences", fun ()
        let result = regex.replace_all("o", "hello world", "0")
        test.assert_eq(result, "hell0 w0rld", nil)
    end)

    test.it("returns original when no match", fun ()
        let result = regex.replace_all("\\d+", "abcdef", "NUM")
        test.assert_eq(result, "abcdef", nil)
    end)
end)

test.describe("regex.split", fun ()
    test.it("splits by pattern", fun ()
        let parts = regex.split(",\\s*", "a, b, c, d")
        test.assert_eq(parts.len(), 4, nil)
        test.assert_eq(parts.get(0), "a", nil)
        test.assert_eq(parts.get(1), "b", nil)
        test.assert_eq(parts.get(2), "c", nil)
        test.assert_eq(parts.get(3), "d", nil)
    end)

    test.it("splits by whitespace", fun ()
        let parts = regex.split("\\s+", "hello   world    foo")
        test.assert_eq(parts.len(), 3, nil)
        test.assert_eq(parts.get(0), "hello", nil)
        test.assert_eq(parts.get(1), "world", nil)
        test.assert_eq(parts.get(2), "foo", nil)
    end)

    test.it("splits by digits", fun ()
        let parts = regex.split("\\d+", "a123b456c")
        test.assert_eq(parts.len(), 3, nil)
        test.assert_eq(parts.get(0), "a", nil)
        test.assert_eq(parts.get(1), "b", nil)
        test.assert_eq(parts.get(2), "c", nil)
    end)
end)

test.describe("regex.is_valid", fun ()
    test.it("validates correct patterns", fun ()
        test.assert_eq(regex.is_valid("\\d+"), true, nil)
        test.assert_eq(regex.is_valid("[a-z]+"), true, nil)
        test.assert_eq(regex.is_valid("^hello$"), true, nil)
    end)

    test.it("rejects invalid patterns", fun ()
        test.assert_eq(regex.is_valid("["), false, nil)
        test.assert_eq(regex.is_valid("("), false, nil)
        test.assert_eq(regex.is_valid("*"), false, nil)
    end)

    test.it("validates complex patterns", fun ()
        test.assert_eq(regex.is_valid("\\w+@\\w+\\.\\w+"), true, nil)
        test.assert_eq(regex.is_valid("\\d{3}-\\d{3}-\\d{4}"), true, nil)
    end)
end)
