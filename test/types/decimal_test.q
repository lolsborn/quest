use "std/test" as test
use "std/decimal" as decimal

test.module("Decimal")

test.describe("Constructor", fun ()
    test.it("creates decimal from string", fun ()
        let d = decimal.new("123.45")
        test.assert_type(d, "Decimal", "Should be Decimal type")
        test.assert_eq(d.to_string(), "123.45", "Should preserve exact value")
    end)

    test.it("creates decimal from number", fun ()
        let d = decimal.new(100.5)
        test.assert_type(d, "Decimal", "Should be Decimal type")
        test.assert_eq(d.to_string(), "100.5", "Should convert number")
    end)

    test.it("creates decimal from large precise string", fun ()
        let d = decimal.new("123456789.123456789")
        test.assert_type(d, "Decimal", "Should be Decimal type")
        test.assert_eq(d.to_string(), "123456789.123456789", "Should preserve precision")
    end)

    test.it("creates decimal from negative string", fun ()
        let d = decimal.new("-456.78")
        test.assert_eq(d.to_string(), "-456.78", "Should handle negative values")
    end)

    test.it("creates decimal from integer string", fun ()
        let d = decimal.new("42")
        test.assert_eq(d.to_string(), "42", "Should handle integers")
    end)

    test.it("creates decimal from existing decimal", fun ()
        let d1 = decimal.new("123.45")
        let d2 = decimal.new(d1)
        test.assert_eq(d2.to_string(), "123.45", "Should clone decimal")
    end)
end)

test.describe("Constants", fun ()
    test.it("creates zero", fun ()
        let d = decimal.zero()
        test.assert_eq(d.to_string(), "0", "Should be zero")
    end)

    test.it("creates one", fun ()
        let d = decimal.one()
        test.assert_eq(d.to_string(), "1", "Should be one")
    end)
end)

test.describe("Arithmetic operations", fun ()
    test.it("adds two decimals", fun ()
        let d1 = decimal.new("123.45")
        let d2 = decimal.new("100.50")
        let result = d1.plus(d2)
        test.assert_eq(result.to_string(), "223.95", "Should add correctly")
    end)

    test.it("adds decimal and number", fun ()
        let d = decimal.new("100.5")
        let result = d.plus(50.25)
        test.assert_eq(result.to_string(), "150.75", "Should add decimal and number")
    end)

    test.it("subtracts two decimals", fun ()
        let d1 = decimal.new("200.75")
        let d2 = decimal.new("50.25")
        let result = d1.minus(d2)
        # rust_decimal may add trailing zeros
        let val = result.to_f64()
        test.assert(val == 150.5, "Should subtract correctly")
    end)

    test.it("subtracts decimal and number", fun ()
        let d = decimal.new("100.5")
        let result = d.minus(25.25)
        test.assert_eq(result.to_string(), "75.25", "Should subtract decimal and number")
    end)

    test.it("multiplies two decimals", fun ()
        let d1 = decimal.new("12.5")
        let d2 = decimal.new("4")
        let result = d1.times(d2)
        let val = result.to_f64()
        test.assert(val == 50.0, "Should multiply correctly")
    end)

    test.it("multiplies decimal and number", fun ()
        let d = decimal.new("10.5")
        let result = d.times(3)
        test.assert_eq(result.to_string(), "31.5", "Should multiply decimal and number")
    end)

    test.it("divides two decimals", fun ()
        let d1 = decimal.new("100")
        let d2 = decimal.new("4")
        let result = d1.div(d2)
        test.assert_eq(result.to_string(), "25", "Should divide correctly")
    end)

    test.it("divides decimal and number", fun ()
        let d = decimal.new("150")
        let result = d.div(3)
        test.assert_eq(result.to_string(), "50", "Should divide decimal and number")
    end)

    test.it("handles division by zero", fun ()
        let d1 = decimal.new("100")
        let d2 = decimal.zero()
        # Division by zero should raise an error - just check that we can catch it
        let error_msg = ""
        try
            let result = d1.div(d2)
            error_msg = "no_error"
        catch e
            error_msg = e.message()
        end
        test.assert(error_msg != "no_error", "Should raise error on division by zero")
    end)

    test.it("calculates modulo", fun ()
        let d1 = decimal.new("17")
        let d2 = decimal.new("5")
        let result = d1.mod(d2)
        test.assert_eq(result.to_string(), "2", "Should calculate modulo")
    end)

    test.it("calculates modulo with decimal", fun ()
        let d1 = decimal.new("17.5")
        let d2 = decimal.new("5")
        let result = d1.mod(d2)
        test.assert_eq(result.to_string(), "2.5", "Should handle decimal modulo")
    end)
end)

test.describe("Comparison operations", fun ()
    test.it("checks equality with decimal", fun ()
        let d1 = decimal.new("123.45")
        let d2 = decimal.new("123.45")
        test.assert(d1.eq(d2), "Equal decimals should be equal")
    end)

    test.it("checks equality with number", fun ()
        let d = decimal.new("100.5")
        test.assert(d.eq(100.5), "Should equal numeric value")
    end)

    test.it("checks inequality with decimal", fun ()
        let d1 = decimal.new("123.45")
        let d2 = decimal.new("200.00")
        test.assert(d1.neq(d2), "Different decimals should be not equal")
    end)

    test.it("checks inequality with non-decimal", fun ()
        let d = decimal.new("100.5")
        test.assert(d.neq("string"), "Decimal should not equal string")
    end)

    test.it("checks greater than", fun ()
        let d1 = decimal.new("200")
        let d2 = decimal.new("100")
        test.assert(d1.gt(d2), "200 should be greater than 100")
        test.assert(not d2.gt(d1), "100 should not be greater than 200")
    end)

    test.it("checks less than", fun ()
        let d1 = decimal.new("100")
        let d2 = decimal.new("200")
        test.assert(d1.lt(d2), "100 should be less than 200")
        test.assert(not d2.lt(d1), "200 should not be less than 100")
    end)

    test.it("checks greater than or equal", fun ()
        let d1 = decimal.new("200")
        let d2 = decimal.new("200")
        let d3 = decimal.new("100")
        test.assert(d1.gte(d2), "Should be gte to equal value")
        test.assert(d1.gte(d3), "Should be gte to lesser value")
        test.assert(not d3.gte(d1), "Should not be gte to greater value")
    end)

    test.it("checks less than or equal", fun ()
        let d1 = decimal.new("100")
        let d2 = decimal.new("100")
        let d3 = decimal.new("200")
        test.assert(d1.lte(d2), "Should be lte to equal value")
        test.assert(d1.lte(d3), "Should be lte to greater value")
        test.assert(not d3.lte(d1), "Should not be lte to lesser value")
    end)
end)

test.describe("Conversion operations", fun ()
    test.it("converts to float", fun ()
        let d = decimal.new("123.45")
        let f = d.to_f64()
        test.assert_type(f, "Num", "Should convert to Num")
        test.assert(f == 123.45, "Should have correct value")
    end)

    test.it("converts to string", fun ()
        let d = decimal.new("987654321.123456789")
        let s = d.to_string()
        test.assert_type(s, "Str", "Should be string")
        test.assert_eq(s, "987654321.123456789", "Should preserve precision")
    end)
end)

test.describe("Object methods", fun ()
    test.it("has class name", fun ()
        let d = decimal.new("123.45")
        test.assert_eq(d.cls(), "Decimal", "Class should be Decimal")
    end)

    test.it("has string representation", fun ()
        let d = decimal.new("123.45")
        test.assert_eq(d._str(), "123.45", "String rep should show value")
    end)

    test.it("has repr representation", fun ()
        let d = decimal.new("123.45")
        test.assert_eq(d._rep(), "Decimal(123.45)", "Repr should show type")
    end)

    test.it("has unique id", fun ()
        let d1 = decimal.new("123.45")
        let d2 = decimal.new("123.45")
        let id1 = d1._id()
        let id2 = d2._id()
        test.assert(id1 != id2, "Different instances should have different IDs")
    end)
end)

test.describe("Precision preservation", fun ()
    test.it("preserves precision in arithmetic", fun ()
        let d1 = decimal.new("0.1")
        let d2 = decimal.new("0.2")
        let result = d1.plus(d2)
        test.assert_eq(result.to_string(), "0.3", "Should avoid float rounding errors")
    end)

    test.it("handles many decimal places", fun ()
        let d1 = decimal.new("1.123456789")
        let d2 = decimal.new("2.987654321")
        let result = d1.plus(d2)
        let val = result.to_f64()
        test.assert(val > 4.11 and val < 4.12, "Should preserve precision")
    end)

    test.it("handles large numbers", fun ()
        let d = decimal.new("9876543210.0123456789")
        test.assert_eq(d.to_string(), "9876543210.0123456789", "Should handle large precise numbers")
    end)
end)
