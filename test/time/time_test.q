# Basic Time Module Tests
# Tests core time functionality

use "std/test" as test
use "std/time" as time

test.module("Time Module Tests - Basic")

test.describe("Module Import", fun ()
    test.it("can import time module", fun ()
        test.assert(time != nil, "time module should not be nil")
    end)
end)

test.describe("Current Time Functions", fun ()
    test.it("can get current timestamp with time.now()", fun ()
        let now = time.now()
        test.assert(now != nil, "now() should return a timestamp")
        test.assert_eq(now.cls(), "Timestamp", "Should be a Timestamp object")
    end)

    test.it("can get current local datetime with time.now_local()", fun ()
        let local = time.now_local()
        test.assert(local != nil, "now_local() should return a datetime")
        test.assert_eq(local.cls(), "Zoned", "Should be a Zoned object")
    end)

    test.it("can get today's date with time.today()", fun ()
        let today = time.today()
        test.assert(today != nil, "today() should return a date")
        test.assert_eq(today.cls(), "Date", "Should be a Date object")
    end)

    test.it("can get current time with time.time_now()", fun ()
        let t = time.time_now()
        test.assert(t != nil, "time_now() should return a time")
        test.assert_eq(t.cls(), "Time", "Should be a Time object")
    end)
end)

test.describe("Date Construction", fun ()
    test.it("can create a date from components", fun ()
        let date = time.date(2025, 10, 1)
        test.assert_eq(date.cls(), "Date", "Should be a Date object")
        test.assert_eq(date.year(), 2025, "Year should be 2025")
        test.assert_eq(date.month(), 10, "Month should be 10")
        test.assert_eq(date.day(), 1, "Day should be 1")
    end)

    test.it("can get day of week from date", fun ()
        let date = time.date(2025, 10, 1)
        test.assert_eq(date.day_of_week(), 3, "Oct 1, 2025 is a Wednesday (3)")
    end)
end)

test.describe("Time Construction", fun ()
    test.it("can create a time from components", fun ()
        let t = time.time(14, 30, 45)
        test.assert_eq(t.cls(), "Time", "Should be a Time object")
        test.assert_eq(t.hour(), 14, "Hour should be 14")
        test.assert_eq(t.minute(), 30, "Minute should be 30")
        test.assert_eq(t.second(), 45, "Second should be 45")
    end)

    test.it("can create a time with nanoseconds", fun ()
        let t = time.time(14, 30, 45, 123456789)
        test.assert_eq(t.nanosecond(), 123456789, "Nanosecond should be 123456789")
    end)
end)

test.describe("DateTime Construction", fun ()
    test.it("can create a datetime in UTC", fun ()
        let dt = time.datetime(2025, 10, 1, 14, 30, 0)
        test.assert_eq(dt.cls(), "Zoned", "Should be a Zoned object")
        test.assert_eq(dt.year(), 2025, "Year should be 2025")
        test.assert_eq(dt.month(), 10, "Month should be 10")
        test.assert_eq(dt.day(), 1, "Day should be 1")
        test.assert_eq(dt.hour(), 14, "Hour should be 14")
        test.assert_eq(dt.minute(), 30, "Minute should be 30")
    end)

    test.it("can create a datetime with timezone", fun ()
        let dt = time.datetime(2025, 10, 1, 14, 30, 0, "America/New_York")
        test.assert_eq(dt.timezone(), "America/New_York", "Timezone should be America/New_York")
    end)
end)

test.describe("Span Construction", fun ()
    test.it("can create a span of days", fun ()
        let span = time.days(5)
        test.assert_eq(span.cls(), "Span", "Should be a Span object")
        test.assert_eq(span.days(), 5, "Should have 5 days")
    end)

    test.it("can create a span of hours", fun ()
        let span = time.hours(3)
        test.assert_eq(span.hours(), 3, "Should have 3 hours")
    end)

    test.it("can create a span of minutes", fun ()
        let span = time.minutes(30)
        test.assert_eq(span.minutes(), 30, "Should have 30 minutes")
    end)

    test.it("can create a span of seconds", fun ()
        let span = time.seconds(90)
        test.assert_eq(span.seconds(), 90, "Should have 90 seconds")
    end)
end)

test.describe("DateTime Arithmetic", fun ()
    test.it("can add days to datetime", fun ()
        let dt = time.datetime(2025, 10, 1, 14, 30, 0)
        let tomorrow = dt.add_days(1)
        test.assert_eq(tomorrow.day(), 2, "Should be Oct 2")
    end)

    test.it("can add hours to datetime", fun ()
        let dt = time.datetime(2025, 10, 1, 14, 30, 0)
        let later = dt.add_hours(5)
        test.assert_eq(later.hour(), 19, "Should be 19:30")
    end)

    test.it("can subtract days from datetime", fun ()
        let dt = time.datetime(2025, 10, 1, 14, 30, 0)
        let yesterday = dt.subtract_days(1)
        test.assert_eq(yesterday.month(), 9, "Should be Sept")
        test.assert_eq(yesterday.day(), 30, "Should be Sept 30")
    end)
end)

test.describe("Date Arithmetic", fun ()
    test.it("can add days to date", fun ()
        let date = time.date(2025, 10, 1)
        let tomorrow = date.add_days(1)
        test.assert_eq(tomorrow.day(), 2, "Should be day 2")
    end)

    test.it("can add months to date", fun ()
        let date = time.date(2025, 10, 1)
        let next_month = date.add_months(1)
        test.assert_eq(next_month.month(), 11, "Should be November")
    end)

    test.it("can add years to date", fun ()
        let date = time.date(2025, 10, 1)
        let next_year = date.add_years(1)
        test.assert_eq(next_year.year(), 2026, "Should be 2026")
    end)
end)

test.describe("DateTime Comparison", fun ()
    test.it("can check if two datetimes are equal", fun ()
        let dt1 = time.datetime(2025, 10, 1, 14, 30, 0)
        let dt2 = time.datetime(2025, 10, 1, 14, 30, 0)
        test.assert(dt1.equals(dt2), "Datetimes should be equal")
    end)

    test.it("can check if datetime is before another", fun ()
        let dt1 = time.datetime(2025, 10, 1, 14, 30, 0)
        let dt2 = time.datetime(2025, 10, 2, 14, 30, 0)
        test.assert(dt1.before(dt2), "dt1 should be before dt2")
    end)

    test.it("can check if datetime is after another", fun ()
        let dt1 = time.datetime(2025, 10, 2, 14, 30, 0)
        let dt2 = time.datetime(2025, 10, 1, 14, 30, 0)
        test.assert(dt1.after(dt2), "dt1 should be after dt2")
    end)
end)

test.describe("Utility Functions", fun ()
    test.it("can check if year is leap year", fun ()
        test.assert(time.is_leap_year(2024), "2024 should be a leap year")
        test.assert(not time.is_leap_year(2025), "2025 should not be a leap year")
        test.assert(time.is_leap_year(2000), "2000 should be a leap year")
        test.assert(not time.is_leap_year(1900), "1900 should not be a leap year")
    end)
end)

test.describe("Timestamp Methods", fun ()
    test.it("can convert timestamp to seconds", fun ()
        let now = time.now()
        let seconds = now.as_seconds()
        test.assert(seconds > 0, "Seconds should be positive")
    end)

    test.it("can convert timestamp to milliseconds", fun ()
        let now = time.now()
        let millis = now.as_millis()
        test.assert(millis > 0, "Milliseconds should be positive")
    end)

    test.it("can convert timestamp to microseconds", fun ()
        let now = time.now()
        let micros = now.as_micros()
        test.assert(micros > 0, "Microseconds should be positive")
    end)
end)

test.describe("Timestamp Creation from Unix Epoch", fun ()
    test.it("can create timestamp from seconds", fun ()
        let ts = time.from_timestamp(1727794245)
        test.assert_eq(ts.cls(), "Timestamp", "Should be a Timestamp")
        test.assert_eq(ts.as_seconds(), 1727794245, "Should have correct seconds")
    end)

    test.it("can create timestamp from milliseconds", fun ()
        let ts = time.from_timestamp_ms(1727794245123)
        test.assert_eq(ts.cls(), "Timestamp", "Should be a Timestamp")
        test.assert_eq(ts.as_millis(), 1727794245123, "Should have correct milliseconds")
    end)

    test.it("can create timestamp from microseconds", fun ()
        let ts = time.from_timestamp_us(1727794245123456)
        test.assert_eq(ts.cls(), "Timestamp", "Should be a Timestamp")
        test.assert_eq(ts.as_micros(), 1727794245123456, "Should have correct microseconds")
    end)

    test.it("can round-trip timestamp through seconds", fun ()
        let original = time.from_timestamp(1700000000)
        let seconds = original.as_seconds()
        let restored = time.from_timestamp(seconds)
        test.assert_eq(restored.as_seconds(), original.as_seconds(), "Should round-trip correctly")
    end)
end)

test.describe("Time Parsing", fun ()
    test.it("can parse ISO 8601 UTC timestamp", fun ()
        let dt = time.parse("2025-10-01T14:30:00Z")
        test.assert_eq(dt.cls(), "Timestamp", "Should parse as Timestamp")
    end)

    test.it("can parse RFC 3339 datetime with offset", fun ()
        let dt = time.parse("2025-10-01T14:30:00-05:00")
        test.assert_eq(dt.cls(), "Timestamp", "Should parse as Timestamp with offset")
    end)

    test.it("can parse date string", fun ()
        let d = time.parse("2025-10-01")
        test.assert_eq(d.cls(), "Date", "Should parse as Date")
        test.assert_eq(d.year(), 2025, "Year should be 2025")
        test.assert_eq(d.month(), 10, "Month should be 10")
        test.assert_eq(d.day(), 1, "Day should be 1")
    end)

    test.it("can parse time string", fun ()
        let t = time.parse("14:30:45")
        test.assert_eq(t.cls(), "Time", "Should parse as Time")
        test.assert_eq(t.hour(), 14, "Hour should be 14")
        test.assert_eq(t.minute(), 30, "Minute should be 30")
        test.assert_eq(t.second(), 45, "Second should be 45")
    end)
end)

test.describe("Date Arithmetic - Duration", fun ()
    test.it("can calculate span between two dates", fun ()
        let date1 = time.date(2025, 10, 1)
        let date2 = time.date(2025, 9, 1)
        let span = date1.since(date2)
        test.assert_eq(span.cls(), "Span", "Should return a Span")
        test.assert_eq(span.days(), 30, "Should be 30 days")
    end)

    test.it("can calculate negative span", fun ()
        let date1 = time.date(2025, 9, 1)
        let date2 = time.date(2025, 10, 1)
        let span = date1.since(date2)
        test.assert_eq(span.days(), -30, "Should be -30 days")
    end)

    test.it("can calculate span across year boundary", fun ()
        let date1 = time.date(2026, 1, 1)
        let date2 = time.date(2025, 12, 1)
        let span = date1.since(date2)
        test.assert_eq(span.days(), 31, "Should be 31 days")
    end)
end)

test.describe("Quarter Operations", fun ()
    test.it("can get quarter from date - Q1", fun ()
        let date = time.date(2025, 1, 15)
        test.assert_eq(date.quarter(), 1, "January should be Q1")

        let date2 = time.date(2025, 3, 31)
        test.assert_eq(date2.quarter(), 1, "March should be Q1")
    end)

    test.it("can get quarter from date - Q2", fun ()
        let date = time.date(2025, 4, 1)
        test.assert_eq(date.quarter(), 2, "April should be Q2")

        let date2 = time.date(2025, 6, 30)
        test.assert_eq(date2.quarter(), 2, "June should be Q2")
    end)

    test.it("can get quarter from date - Q3", fun ()
        let date = time.date(2025, 7, 15)
        test.assert_eq(date.quarter(), 3, "July should be Q3")
    end)

    test.it("can get quarter from date - Q4", fun ()
        let date = time.date(2025, 10, 1)
        test.assert_eq(date.quarter(), 4, "October should be Q4")
    end)

    test.it("can get quarter from zoned datetime", fun ()
        let dt = time.datetime(2025, 5, 15, 10, 0, 0)
        test.assert_eq(dt.quarter(), 2, "May should be Q2")
    end)

    test.it("can get start of quarter", fun ()
        let dt = time.datetime(2025, 5, 15, 14, 30, 0)
        let q_start = dt.start_of_quarter()

        test.assert_eq(q_start.year(), 2025, "Year should be 2025")
        test.assert_eq(q_start.month(), 4, "Q2 starts in April")
        test.assert_eq(q_start.day(), 1, "Should be first day")
        test.assert_eq(q_start.hour(), 0, "Should be midnight")
    end)

    test.it("can get end of quarter", fun ()
        let dt = time.datetime(2025, 5, 15, 14, 30, 0)
        let q_end = dt.end_of_quarter()

        test.assert_eq(q_end.year(), 2025, "Year should be 2025")
        test.assert_eq(q_end.month(), 6, "Q2 ends in June")
        test.assert_eq(q_end.day(), 30, "Should be last day of June")
        test.assert_eq(q_end.hour(), 23, "Should be 23:59:59")
    end)
end)

test.describe("Span Humanize", fun ()
    test.it("humanizes seconds - past", fun ()
        let span = time.seconds(-30)
        let result = span.humanize()
        test.assert_eq(result, "30 seconds ago", "Should say '30 seconds ago'")
    end)

    test.it("humanizes seconds - future", fun ()
        let span = time.seconds(45)
        let result = span.humanize()
        test.assert_eq(result, "in 45 seconds", "Should say 'in 45 seconds'")
    end)

    test.it("humanizes minutes - past", fun ()
        let span = time.minutes(-5)
        let result = span.humanize()
        test.assert_eq(result, "5 minutes ago", "Should say '5 minutes ago'")
    end)

    test.it("humanizes hours - future", fun ()
        let span = time.hours(2)
        let result = span.humanize()
        test.assert_eq(result, "in 2 hours", "Should say 'in 2 hours'")
    end)

    test.it("humanizes days - past", fun ()
        let span = time.days(-7)
        let result = span.humanize()
        test.assert_eq(result, "7 days ago", "Should say '7 days ago'")
    end)

    test.it("handles singular forms", fun ()
        let span1 = time.seconds(1)
        test.assert_eq(span1.humanize(), "in 1 second", "Should say '1 second' not '1 seconds'")

        let span2 = time.minutes(-1)
        test.assert_eq(span2.humanize(), "1 minute ago", "Should say '1 minute' not '1 minutes'")

        let span3 = time.hours(1)
        test.assert_eq(span3.humanize(), "in 1 hour", "Should say '1 hour' not '1 hours'")

        let span4 = time.days(-1)
        test.assert_eq(span4.humanize(), "1 day ago", "Should say '1 day' not '1 days'")
    end)
end)

test.describe("Timestamp Since", fun ()
    test.it("can calculate span between timestamps", fun ()
        let ts1 = time.from_timestamp(1000000)
        let ts2 = time.from_timestamp(996400)
        let span = ts1.since(ts2)

        test.assert_eq(span.cls(), "Span", "Should return a Span")
        test.assert_eq(span.as_hours(), 1.0, "Should be 1 hour")
    end)

    test.it("timestamp.since works with negative differences", fun ()
        let ts1 = time.from_timestamp(1000000)
        let ts2 = time.from_timestamp(1003600)
        let span = ts1.since(ts2)

        test.assert_eq(span.as_hours(), -1.0, "Should be -1 hour")
    end)
end)
