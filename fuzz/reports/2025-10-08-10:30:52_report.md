# Quest Fuzz Test Findings Report

**Generated:** 2025-10-08 10:30:52
**Sessions Analyzed:** 001, 002, 003, 004, 005, 006

---

## Executive Summary

- **Total Bugs:** 10 (Critical: 0, High: 3, Medium: 6, Low: 1)
- **Total Improvements:** 27 (High: 9, Medium: 11, Low: 7)
- **Sessions:** 6 fuzz test sessions covering varargs, kwargs, named args, decorators, exceptions, and type system

### Key Themes

1. **Parser Limitations:** Function calls in default parameters not supported; reserved keywords cause confusing errors
2. **Decorator System:** Cannot use locally-defined decorator types; limited scope resolution
3. **Lambda Completeness:** Lambdas don't support `**kwargs` despite regular functions supporting it
4. **Type System Field Visibility:** No `pub` keyword implemented; all fields private by default with unclear workarounds
5. **Error Message Quality:** Many parse errors lack context about reserved keywords or suggest fixes
6. **API Consistency:** Exception `.type()` returns Type object vs string; nil doesn't support `.cls()`

---

## Critical Issues

**None identified.** All bugs are in the High to Low severity range, mostly missing features or API inconsistencies rather than crashes or data corruption.

---

## High Priority Bugs

### Parser / Function Parameters

#### 1. Function Calls Not Supported in Default Parameters (Sessions 004, 005)

**Description:** Using function calls as default parameter values causes parse errors, even though QEP-033 specifies defaults should be evaluated at call time.

**Reproduction:**
```quest
fun increment()
    return 1
end

fun test(x = increment())  # Parse error
    return x
end
```

**Error:**
```
Parse error in function body:  --> 1:1
  |
1 | )
  | ^---
  = expected program
```

**Impact:** Severely limits default parameter expressiveness - cannot use factory functions, computed defaults, timestamps, UUIDs, or any dynamic initialization patterns common in Python/JavaScript.

**Suggested Fix:** Extend parser's expression handling for default parameters to include method calls and full expression syntax.

---

#### 2. Decorator Type Lookup Fails for Local Types (Session 006)

**Description:** When using `@TypeName.new()` syntax where `TypeName` is defined in the same file, the decorator system fails with "Decorator not found".

**Reproduction:**
```quest
type LogArgs
    func
    fun _call(*args, **kwargs)
        return self.func(*args, **kwargs)
    end
    fun _name() return self.func._name() end
    fun _doc() return self.func._doc() end
    fun _id() return self.func._id() end
end

# Fails with "Decorator 'LogArgs.new' not found"
@LogArgs.new(call_count: 0)
fun test_func()
    return "hello"
end
```

**Error:**
```
RuntimeErr: Decorator 'LogArgs.new' not found
```

**Impact:**
- Cannot define custom decorator types in user code
- Forces all decorators to be imported from stdlib
- Breaks decorator composition and project-specific patterns

**Possible Cause:** Decorator resolution phase happens before type definitions are fully registered, or decorators only look in a global decorator registry rather than general variable scope.

**Suggested Fix:** Allow decorators to resolve types from current scope, not just imported modules.

---

#### 3. Private Field Access with No Public Keyword (Sessions 001, 002)

**Description:** Type fields are private by default with no documented way to make them public. The `pub` keyword is mentioned in CLAUDE.md but not implemented.

**Reproduction:**
```quest
type Point
    x: Int
    y: Int
end

let p = Point.new(x: 10, y: 20)
test.assert_eq(p.x, 10)  # AttrErr: Field 'x' of type Point is private
```

**Impact:**
- Cannot test or validate type instances properly
- Makes types difficult to use for data objects
- Forces verbose getter methods for simple field access

**Workaround:** Add getter methods manually (verbose and defeats purpose of fields).

**Suggested Fix:**
- **Option A:** Implement `pub` keyword (Rust-style): `pub x: Int`
- **Option B:** Make fields public by default (Python/Ruby-style)

Documentation in CLAUDE.md shows `pub` keyword but it doesn't work in practice.

---

## Medium Priority Bugs

### Lambda / Function Parameters

#### 4. Lambdas Don't Support **kwargs (Sessions 004, 005)

**Description:** Lambda functions cannot accept `**kwargs` parameter even though regular functions support it. Lambda parses successfully but fails at runtime.

**Reproduction:**
```quest
let lambda_kwargs = fun (**opts)
    opts.len()
end

lambda_kwargs(a: 1, b: 2, c: 3)  # ArgErr: Unknown keyword arguments: c, a, b
```

**Impact:** Limits functional programming patterns - can't create higher-order functions that accept arbitrary keyword arguments.

**Suggested Fix:** Complete kwargs implementation in lambda evaluation to match regular function behavior.

---

#### 5. Reserved Keyword `step` Cannot Be Used as Parameter Name (Session 005)

**Description:** The keyword `step` (used in range expressions) cannot be used as a parameter name, causing confusing parse errors.

**Reproduction:**
```quest
fun make_range(start, end = 10, step = 1)  # Parse error
    # ...
end
```

**Error:**
```
Parse error:  --> 2:17
  |
2 | fun test(start, step = 1)
  |                 ^---
  = expected parameter, varargs, or kwargs
```

**Impact:** Confusing for users writing range/iteration utilities where `step` is a natural parameter name. Error message doesn't mention reserved keywords.

**Workaround:** Use alternative names like `increment`, `stride`, `delta`.

**Suggested Fix:** Either implement contextual keywords (so `step` is only reserved in range context) or provide clear error: "'step' is a reserved keyword and cannot be used as a parameter name".

---

#### 6. Reserved Keyword `end` Cannot Be Used as Parameter Name (Session 005)

**Description:** Similar to `step`, the keyword `end` (block terminator) cannot be used as parameter name.

**Reproduction:**
```quest
fun make_range(start, end = 10)  # Fails
fun make_range(start, finish = 10)  # Works
```

**Impact:** Common parameter names like `end`, `start`, `step` are unexpectedly invalid.

**Suggested Fix:** Same as Bug #5 - contextual keywords or better error messages.

---

### Exception System

#### 7. Exception `.type()` Returns Type Object Instead of String (Session 003)

**Description:** The `.type()` method on exception objects returns a QType object instead of a string, making string comparisons fail.

**Reproduction:**
```quest
try
    raise ValueErr.new("test")
catch e: ValueErr
    puts(e.type())  # Prints "ValueErr" but it's a Type object
    test.assert_eq(e.type(), "ValueErr")  # Fails - Type != String
end
```

**Expected:** `e.type()` should return string `"ValueErr"`

**Actual:** Returns Type object that displays as `ValueErr` but isn't equal to string

**Impact:** Makes programmatic exception type checking difficult. Users need to use type annotations in catch blocks or compare against Type objects.

**Suggested Fix:**
- **Option A:** Make `.type()` return string representation
- **Option B:** Add `.type_name()` or `.type_str()` for string version
- **Option C:** Document clearly and provide conversion method

---

### Decorator System

#### 8. Decorator Instance Creation with Required Fields (Session 006)

**Description:** Cannot use pre-instantiated decorator instances. System complains about missing required field 'func' which should be set automatically.

**Reproduction:**
```quest
let log1 = LogArgs.new(call_count: 0)

@log1  # ArgErr: Required field 'func' not provided
fun test()
    return "test"
end
```

**Impact:**
- Cannot reuse decorator instances
- Cannot configure decorators outside of decoration site
- Limits decorator patterns

**Suggested Fix:** Allow decorator syntax to accept already-instantiated objects, with `func` field set automatically during decoration.

---

#### 9. Decorators Not Supported on Type Methods (Session 002)

**Description:** Decorators cannot be applied to instance or static methods within type definitions.

**Reproduction:**
```quest
use "std/decorators" as dec
let Timing = dec.Timing

type Shape
    @Timing  # Fails
    fun draw()
        # ...
    end
end
```

**Error:**
```
TypeErr: Decorators on methods are not yet fully supported. Decorators work on standalone functions and will be extended to methods in a future update.
```

**Status:** Known limitation per error message; needs implementation.

**Impact:** Cannot use timing, caching, logging, retry decorators on type methods.

---

## Low Priority Bugs

### API Consistency

#### 10. Nil Does Not Support `.cls()` Method (Session 004)

**Description:** While most types support `.cls()` method, `nil` does not.

**Reproduction:**
```quest
let x = nil
puts(x.cls())  # TypeErr: Type Nil does not support method calls
```

**Workaround:** Use `== nil` comparison.

**Impact:** Minor API inconsistency.

**Suggested Fix:** Either support `.cls()` returning "Nil", or document that nil is special case.

---

## High Priority Improvements

### Parser / Language Features

#### 1. Support Function Calls in Default Parameters (Sessions 004, 005)

**Current:** Parse error when using function calls as defaults
**Needed:** Allow arbitrary expressions including function calls per QEP-033 spec

**Use Cases:**
```quest
fun with_timestamp(ts = time.now())  # Dynamic timestamp each call
fun with_uuid(id = uuid.v4())        # Fresh UUID each call
fun log(level = get_default_level(), message)  # Runtime config
```

**Benefit:** Enables lazy evaluation patterns and dynamic defaults matching Python/JavaScript behavior.

---

#### 2. Support **kwargs in Lambda Functions (Sessions 004, 005)

**Current:** Lambdas parse with `**kwargs` but fail at runtime
**Needed:** Complete kwargs implementation in lambda evaluation

**Use Cases:**
```quest
let make_config = fun (**opts) opts end
let config = make_config(host: "localhost", port: 8080)

# Decorator wrapper pattern:
let with_logging = fun (func)
    fun (*args, **kwargs)
        puts("Calling " .. func._name())
        func(*args, **kwargs)
    end
end
```

**Benefit:** Enables functional programming patterns and consistent lambda/function feature parity.

---

#### 3. Implement Field Visibility (pub keyword) (Sessions 001, 002)

**Current:** All fields private by default; `pub` keyword in docs but not implemented
**Needed:** Working `pub` keyword for field declarations

**Suggested Syntax (Rust-style):**
```quest
type Point
    pub x: Int      # Public - accessible as point.x
    pub y: Int      # Public
    secret: Str     # Private - only in methods
end
```

**Alternative:** Consider `struct` keyword for all-public data types:
```quest
struct Point
    x: Int  # Public by default
    y: Int
end
```

**Benefit:** Makes data types usable without verbose getters; matches documented behavior.

---

#### 4. Allow Decorators to Reference Local Types (Session 006)

**Current:** Decorators can only be imported from modules
**Needed:** Decorator scope resolution in current file

**Use Case:**
```quest
type MyDecorator
    func
    fun _call(*args, **kwargs)
        # Custom logic
    end
    # ... other methods
end

@MyDecorator.new(config: value)  # Should work
fun my_function()
    # ...
end
```

**Benefit:** Enables custom project-specific decorators without requiring stdlib.

---

#### 5. Support Contextual Keywords (Session 005)

**Current:** Keywords like `end`, `step`, `in`, `to` are globally reserved
**Needed:** Context-sensitive keyword parsing

**Example:**
```quest
# Should work but doesn't:
fun make_range(start, end, step = 1)  # 'end' and 'step' as params
    # 'end' keyword only reserved for closing blocks
end
```

**Benefit:** Natural naming matching Python/Ruby conventions; less surprising for users.

---

#### 6. Support Decorator Instance Reuse (Session 006)

**Current:** Cannot pre-instantiate and reuse decorator instances
**Needed:** Accept already-instantiated decorators

**Use Case:**
```quest
let cache_config = Cache.new(max_size: 100, ttl: 300)

@cache_config
fun query1() end

@cache_config  # Reuse same config
fun query2() end
```

**Benefit:** Reduces boilerplate, enables decorator configuration reuse.

---

#### 7. Extend Decorator Support to Type Methods (Session 002)

**Current:** Error message says "not yet fully supported"
**Needed:** Decorators on instance methods, static methods, trait implementations

**Use Cases:**
```quest
type DataService
    @Cache(max_size: 100)
    fun fetch_data(id)
        # ...
    end

    @Timing
    @Retry(attempts: 3)
    fun save_data(data)
        # ...
    end
end
```

**Benefit:** Critical for real-world use - timing, caching, logging, retry logic on methods.

---

#### 8. F-String Expression Support (Session 006)

**Current:** F-strings cannot contain method calls or property access
**Needed:** Full expression support in interpolation

**Examples that should work:**
```quest
f"Count: {self.count.str()}"        # Method calls
f"Index {i.str()} = {arr[i]}"       # Indexing
f"Value: {obj.method().field}"      # Chained access
```

**Workaround:** Extract to temp variables first.

**Benefit:** More concise and readable code matching Python f-string behavior.

---

#### 9. Better Error Messages for Reserved Keywords (Session 005)

**Current:** Generic "expected parameter, varargs, or kwargs" error
**Needed:** Specific error mentioning keyword with suggestions

**Suggested Error:**
```
Parse error: 'step' is a reserved keyword and cannot be used as a parameter name
       Did you mean: increment, stride, delta?
```

**Benefit:** Much better developer experience; reduces debugging time and frustration.

---

## Medium Priority Improvements

### Error Messages

#### 10. Better Context for Private Field Access Errors (Sessions 001, 002)

**Current:**
```
AttrErr: Field 'value' of type Calculator is private
```

**Suggested:**
```
AttrErr: Field 'value' of type Calculator is private
  Hint: Add 'pub' before the field declaration to make it public:
        type Calculator
            pub value: Int
        end
```

**Benefit:** Guides users to solution without searching docs.

---

#### 11. Better Argument Order Error Messages (Session 004)

**Current:**
```
ArgErr: Positional argument cannot follow keyword argument
```

**Suggested:**
```
ArgErr: In call to 'configure': Positional argument "file1.txt" cannot follow keyword argument 'command'
```

**Benefit:** Shows exactly which call and arguments violated the rule.

---

### Documentation

#### 12. Document Dict Key Iteration Order (Session 004)

**Current:** Dict key iteration order appears to vary
**Needed:** Clarify if it's insertion order (Python 3.7+), undefined, or alphabetical

**Benefit:** Sets clear expectations for developers relying on dict ordering.

---

#### 13. Document Current Decorator Limitations (Sessions 002, 006)

**Current:** CLAUDE.md says decorators work on "functions, instance methods, static methods" but this isn't true
**Needed:** Update docs to reflect current state and roadmap

**Should Document:**
- Decorator types must implement `_call`, `_name`, `_doc`, `_id`
- Requirement for `func` field
- Automatic `self.func` binding during decoration
- Current limitations on scope/lookup
- Methods not yet supported (coming soon)

**Benefit:** Aligns user expectations with reality.

---

#### 14. Document Reserved Keywords List (Session 005)

**Current:** Users discover reserved keywords by trial and error
**Needed:** Complete list of reserved keywords in documentation

**Keywords to document:** `end`, `step`, `in`, `to`, `until`, `if`, `elif`, `else`, `fun`, `let`, `const`, `type`, `trait`, `impl`, etc.

**Benefit:** Prevents confusion when naming parameters/variables.

---

#### 15. Clarify Default Parameter Expression Limitations (Session 005)

**Current:** QEP-033 mentions defaults can reference earlier params, but function calls don't work
**Needed:** Clear statement of current limitations

**Documentation Should State:**
- ✅ Default parameters can reference earlier params: `fun f(x, y = x + 1)`
- ✅ Default parameters can use literals and binary expressions
- ❌ Default parameters cannot include function calls yet: `fun f(x = get())` (planned)

**Benefit:** Prevents confusion about feature completeness.

---

#### 16. Document Exception Object Methods (Session 003)

**Current:** Limited documentation on exception methods
**Needed:** Clear API documentation

**Should Document:**
- `.type()` - Returns Type object (not string!)
- `.message()` - The error message string
- `.stack()` - Stack trace (format TBD)
- `.str()` - String representation
- How to compare types (use typed catch blocks)

**Benefit:** Clarifies API surface and usage patterns.

---

### API Improvements

#### 17. Add `.type_name()` Method to Exceptions (Session 003)

**Current:** `.type()` returns Type object, not string
**Suggested:** Add `.type_name()` that returns string like "ValueErr"

**Use Case:**
```quest
try
    risky()
catch e: Err
    if e.type_name() == "ValueErr"  # String comparison
        # ...
    end
end
```

**Benefit:** Makes programmatic type checking easier.

---

#### 18. Support Multi-line Function Calls (Session 005)

**Current:** Unclear if supported; didn't parse in tests
**Needed:** Verify and document multi-line call support

**Desired:**
```quest
let result = configure(
    host: "localhost",
    port: 8080,
    ssl: true,
    debug: false
)
```

**Benefit:** Improves readability for functions with many parameters.

---

#### 19. Consider .is(Nil) Support (Session 004)

**Current:** Must use `== nil`; `.is(nil)` doesn't work
**Suggested:** Either add `Nil` as type constant or document `== nil` as canonical

**Benefit:** API consistency across all types.

---

## Low Priority Improvements

### Future Features (QEP-034 Phase 3)

#### 20. Array Unpacking Syntax (Session 004)

**Suggested:**
```quest
let args = [1, 2, 3]
sum(*args)  # Unpacks array to positional arguments
```

**Status:** Mentioned in QEP-034 Phase 3; not yet implemented.

**Benefit:** Cleaner dynamic argument handling.

---

#### 21. Dict Unpacking for Kwargs (Session 004)

**Suggested:**
```quest
let options = {host: "localhost", port: 8080}
connect(**options)  # Unpacks dict to keyword arguments
```

**Status:** Mentioned in QEP-034 Phase 3; not yet implemented.

**Benefit:** Enables dynamic keyword argument construction.

---

### Syntax Considerations

#### 22. Struct Keyword for Public Data Types (Session 001)

**Suggested:**
```quest
# All fields public by default
struct Point
    x: Int
    y: Int
end

# Equivalent to:
type Point
    pub x: Int
    pub y: Int
end
```

**Benefit:** Less boilerplate for pure data types while keeping `type` for encapsulated objects.

---

#### 23. Property Decorators / Getters-Setters (Session 001)

**Suggested Python-style properties:**
```quest
type Temperature
    celsius: Float

    @property
    fun fahrenheit()
        self.celsius * 9.0 / 5.0 + 32.0
    end

    @setter
    fun fahrenheit(value)
        self.celsius = (value - 32.0) * 5.0 / 9.0
    end
end

let temp = Temperature.new(celsius: 0.0)
puts(temp.fahrenheit)        # 32.0 (looks like field)
temp.fahrenheit = 100.0      # Setter
```

**Benefit:** Clean field-like syntax while maintaining encapsulation.

---

#### 24. Document Operator Consistency (Session 006)

**Observation:** Quest uses `and`/`or` keywords instead of `&&`/`||` operators.

**Current:**
```quest
if x > 0 and y < 10
if a == 1 or b == 2
```

**Suggestion:** Document this clearly, or consider supporting both forms for compatibility.

**Benefit:** Reduces surprise for developers from C-family languages.

---

### Testing Improvements

#### 25. Test Framework Assertion Output Clarity (Session 003)

**Current:** Assertion failures appear in "Captured stdout" even when tests pass
**Suggested:** Make assertion output clearer or suppress details when tests pass

**Benefit:** Less confusing test output.

---

### Documentation Completeness

#### 26. Expand Type Field Documentation (Sessions 001, 002)

**Current:** CLAUDE.md type examples don't show `pub` keyword usage
**Needed:** Complete examples showing field visibility

**Should Include:**
```quest
type Person
    pub name: Str      # Public - accessible as person.name
    pub age: Int       # Public
    secret: Str        # Private - only in methods

    fun get_secret()
        self.secret    # Private field access via method
    end
end
```

**Benefit:** Clear examples prevent confusion.

---

#### 27. Document Varargs/Kwargs Success (Session 001)

**Positive Finding:** All varargs (`*args`) and kwargs (`**kwargs`) features tested worked flawlessly in regular functions:
- Basic collection ✓
- With required parameters ✓
- With default parameters ✓
- Named argument reordering ✓
- Skipping defaults with named args ✓
- Combining all parameter types ✓
- Nested closures over varargs ✓

**Suggestion:** Highlight these successes in documentation with examples.

**Benefit:** Builds confidence in feature maturity.

---

## Recommendations

### Immediate Actions (Sprint 1)

1. **Implement `pub` keyword for field visibility** (Bug #3, Improvement #3)
   - High impact on usability
   - Already documented in CLAUDE.md
   - Unblocks type system testing

2. **Fix decorator scope resolution** (Bug #2, Improvement #4)
   - Enables custom decorators
   - Critical for real-world usage
   - Relatively isolated change

3. **Add function call support to default parameters** (Bug #1, Improvement #1)
   - Completes QEP-033 implementation
   - Common use case (timestamps, UUIDs, factories)
   - Unblocks dynamic defaults

### Short-term Fixes (Sprint 2)

4. **Complete lambda `**kwargs` implementation** (Bug #4, Improvement #2)
   - Achieves lambda/function parity
   - Enables functional programming patterns
   - Should be straightforward runtime fix

5. **Improve reserved keyword error messages** (Bugs #5, #6, Improvement #9)
   - Low effort, high developer experience impact
   - Quick win for better errors

6. **Add `.type_name()` to exceptions** (Bug #7, Improvement #17)
   - Simple API addition
   - Clarifies exception type checking

### Medium-term Enhancements (Sprint 3+)

7. **Extend decorators to type methods** (Bug #9, Improvement #7)
   - High value for production code
   - Requires careful `self` parameter handling

8. **Implement contextual keywords** (Bugs #5, #6, Improvement #5)
   - Parser enhancement
   - Reduces surprise for Python/Ruby users

9. **Support decorator instance reuse** (Bug #8, Improvement #6)
   - Enables decorator configuration patterns
   - Requires decorator lifecycle changes

### Documentation Updates (Ongoing)

10. **Update CLAUDE.md with all current limitations**
    - Field visibility (`pub` status)
    - Decorator limitations (methods, scope)
    - Default parameter expression limits
    - Reserved keywords list
    - Exception API methods

11. **Add troubleshooting guide** for common errors:
    - "Field is private" → add `pub`
    - "Decorator not found" → check scope/imports
    - "Reserved keyword" → list alternatives

---

## Pattern Analysis

### Recurring Themes

1. **Parser Expression Handling:** Multiple bugs involve parser not accepting full expressions (default params, f-strings)

2. **Feature Parity Gaps:** Lambdas missing `**kwargs` despite functions having it; inconsistent decorator support

3. **Documentation Lag:** Several features documented but not implemented (`pub` keyword, decorator methods)

4. **Error Message Quality:** Many parse errors lack context about reserved keywords, don't suggest fixes

5. **Type System Maturity:** Field visibility system needs completion; currently blocks practical usage

### Root Cause Candidates

- **Parser:** May need refactoring to handle full expression syntax in more contexts
- **Decorator System:** Scope resolution timing issue; may resolve types too early
- **Lambda Evaluation:** Missing kwargs handling code that exists for regular functions
- **Field Visibility:** Parsing may exist but runtime enforcement incomplete

### Testing Insights

- **What Works Well:** Varargs, named args, exception hierarchies, basic type system, trait implementations
- **What Needs Work:** Decorator scope, lambda kwargs, parser expression support, field visibility
- **High Confidence Areas:** Core parameter handling is solid (required, optional, varargs, named args all work in functions)

---

## Conclusion

Quest's core language features are **solid and production-ready** for:
- Function parameters (varargs, named args, defaults with literals)
- Exception system (hierarchical catching, typed exceptions)
- Type system basics (types, traits, methods)

The main gaps are in:
- **Parser expression support** (function calls in defaults, complex f-strings)
- **Decorator system maturity** (scope resolution, method support)
- **Lambda/function parity** (kwargs in lambdas)
- **Field visibility** (pub keyword implementation)

Recommended priority is to **complete the field visibility system** first (highest user impact), then **fix decorator scope resolution** (enables custom decorators), then **add function calls to default parameters** (completes QEP-033). These three fixes would address the most common pain points discovered in fuzz testing.

The language shows strong fundamentals with clear implementation paths forward for the remaining gaps.